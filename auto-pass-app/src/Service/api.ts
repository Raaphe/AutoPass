/* tslint:disable */
/* eslint-disable */
/**
 * OpenApi specification - AutoPass
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Contact: raphaelpaquin19@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AbstractJsonSchemaPropertyObject
 */
export interface AbstractJsonSchemaPropertyObject {
    /**
     * 
     * @type {string}
     * @memberof AbstractJsonSchemaPropertyObject
     */
    'title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AbstractJsonSchemaPropertyObject
     */
    'readOnly'?: boolean;
}
/**
 * @type Authenticate400Response
 * @export
 */
export type Authenticate400Response = string | { [key: string]: string; };

/**
 * 
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationResponse
     */
    'user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'user_email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthenticationResponse
     */
    'user_authorities'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'token_type'?: string;
}
/**
 * 
 * @export
 * @interface CollectionModelObject
 */
export interface CollectionModelObject {
    /**
     * 
     * @type {CollectionModelObjectEmbedded}
     * @memberof CollectionModelObject
     */
    '_embedded'?: CollectionModelObjectEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof CollectionModelObject
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface CollectionModelObjectEmbedded
 */
export interface CollectionModelObjectEmbedded {
    /**
     * 
     * @type {Array<object>}
     * @memberof CollectionModelObjectEmbedded
     */
    'objects'?: Array<object>;
}
/**
 * 
 * @export
 * @interface EntityModelMembership
 */
export interface EntityModelMembership {
    /**
     * 
     * @type {number}
     * @memberof EntityModelMembership
     */
    'membershipDurationDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntityModelMembership
     */
    'price'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelMembership
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelMembership
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelPass
 */
export interface EntityModelPass {
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityModelPass
     */
    'pass'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelPass
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelPaymentType
 */
export interface EntityModelPaymentType {
    /**
     * 
     * @type {string}
     * @memberof EntityModelPaymentType
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelPaymentType
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityModelPaymentType
     */
    'cvv'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelPaymentType
     */
    'pan'?: string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelPaymentType
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelTicket
 */
export interface EntityModelTicket {
    /**
     * 
     * @type {number}
     * @memberof EntityModelTicket
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntityModelTicket
     */
    'price'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelTicket
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelTicket
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelToken
 */
export interface EntityModelToken {
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelToken
     */
    'revoked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityModelToken
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelToken
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelToken
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelUser
 */
export interface EntityModelUser {
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'role'?: EntityModelUserRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'accountNonLocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'username'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'accountNonExpired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'credentialsNonExpired'?: boolean;
    /**
     * 
     * @type {Array<GrantedAuthority>}
     * @memberof EntityModelUser
     */
    'authorities'?: Array<GrantedAuthority>;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelUser
     */
    '_links'?: { [key: string]: Link; };
}

export const EntityModelUserRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type EntityModelUserRoleEnum = typeof EntityModelUserRoleEnum[keyof typeof EntityModelUserRoleEnum];

/**
 * 
 * @export
 * @interface EntityModelUserWallet
 */
export interface EntityModelUserWallet {
    /**
     * 
     * @type {number}
     * @memberof EntityModelUserWallet
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUserWallet
     */
    'memberShipEnds'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUserWallet
     */
    'membershipActive'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelUserWallet
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'path'?: string;
    /**
     * 
     * @type {Array<ErrorResponseStackTraceElementsInner>}
     * @memberof ErrorResponse
     */
    'stackTraceElements'?: Array<ErrorResponseStackTraceElementsInner>;
}
/**
 * 
 * @export
 * @interface ErrorResponseStackTraceElementsInner
 */
export interface ErrorResponseStackTraceElementsInner {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'classLoaderName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'moduleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'moduleVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'methodName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'fileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'lineNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'className'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'nativeMethod'?: boolean;
}
/**
 * 
 * @export
 * @interface GrantedAuthority
 */
export interface GrantedAuthority {
    /**
     * 
     * @type {string}
     * @memberof GrantedAuthority
     */
    'authority'?: string;
}
/**
 * 
 * @export
 * @interface IsLoggedInDTO
 */
export interface IsLoggedInDTO {
    /**
     * 
     * @type {string}
     * @memberof IsLoggedInDTO
     */
    'accessToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof IsLoggedInDTO
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: AbstractJsonSchemaPropertyObject; }}
     * @memberof Item
     */
    'properties'?: { [key: string]: AbstractJsonSchemaPropertyObject; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Item
     */
    'requiredProperties'?: Array<string>;
}
/**
 * 
 * @export
 * @interface JsonSchema
 */
export interface JsonSchema {
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: AbstractJsonSchemaPropertyObject; }}
     * @memberof JsonSchema
     */
    'properties'?: { [key: string]: AbstractJsonSchemaPropertyObject; };
    /**
     * 
     * @type {Array<string>}
     * @memberof JsonSchema
     */
    'requiredProperties'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: Item; }}
     * @memberof JsonSchema
     */
    'definitions'?: { [key: string]: Item; };
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    '$schema'?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'hreflang'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'deprecation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Link
     */
    'templated'?: boolean;
}
/**
 * 
 * @export
 * @interface MembershipRequestBody
 */
export interface MembershipRequestBody {
    /**
     * 
     * @type {number}
     * @memberof MembershipRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof MembershipRequestBody
     */
    'membershipDurationDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof MembershipRequestBody
     */
    'price'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MembershipRequestBody
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface PageMetadata
 */
export interface PageMetadata {
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelMembership
 */
export interface PagedModelEntityModelMembership {
    /**
     * 
     * @type {PagedModelEntityModelMembershipEmbedded}
     * @memberof PagedModelEntityModelMembership
     */
    '_embedded'?: PagedModelEntityModelMembershipEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelMembership
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelMembership
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelMembershipEmbedded
 */
export interface PagedModelEntityModelMembershipEmbedded {
    /**
     * 
     * @type {Array<EntityModelMembership>}
     * @memberof PagedModelEntityModelMembershipEmbedded
     */
    'memberships'?: Array<EntityModelMembership>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPass
 */
export interface PagedModelEntityModelPass {
    /**
     * 
     * @type {PagedModelEntityModelPassEmbedded}
     * @memberof PagedModelEntityModelPass
     */
    '_embedded'?: PagedModelEntityModelPassEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelPass
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelPass
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPassEmbedded
 */
export interface PagedModelEntityModelPassEmbedded {
    /**
     * 
     * @type {Array<EntityModelPass>}
     * @memberof PagedModelEntityModelPassEmbedded
     */
    'passes'?: Array<EntityModelPass>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPaymentType
 */
export interface PagedModelEntityModelPaymentType {
    /**
     * 
     * @type {PagedModelEntityModelPaymentTypeEmbedded}
     * @memberof PagedModelEntityModelPaymentType
     */
    '_embedded'?: PagedModelEntityModelPaymentTypeEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelPaymentType
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelPaymentType
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPaymentTypeEmbedded
 */
export interface PagedModelEntityModelPaymentTypeEmbedded {
    /**
     * 
     * @type {Array<EntityModelPaymentType>}
     * @memberof PagedModelEntityModelPaymentTypeEmbedded
     */
    'paymentTypes'?: Array<EntityModelPaymentType>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelTicket
 */
export interface PagedModelEntityModelTicket {
    /**
     * 
     * @type {PagedModelEntityModelTicketEmbedded}
     * @memberof PagedModelEntityModelTicket
     */
    '_embedded'?: PagedModelEntityModelTicketEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelTicket
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelTicket
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelTicketEmbedded
 */
export interface PagedModelEntityModelTicketEmbedded {
    /**
     * 
     * @type {Array<EntityModelTicket>}
     * @memberof PagedModelEntityModelTicketEmbedded
     */
    'tickets'?: Array<EntityModelTicket>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelToken
 */
export interface PagedModelEntityModelToken {
    /**
     * 
     * @type {PagedModelEntityModelTokenEmbedded}
     * @memberof PagedModelEntityModelToken
     */
    '_embedded'?: PagedModelEntityModelTokenEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelToken
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelToken
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelTokenEmbedded
 */
export interface PagedModelEntityModelTokenEmbedded {
    /**
     * 
     * @type {Array<EntityModelToken>}
     * @memberof PagedModelEntityModelTokenEmbedded
     */
    'tokens'?: Array<EntityModelToken>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUser
 */
export interface PagedModelEntityModelUser {
    /**
     * 
     * @type {PagedModelEntityModelUserEmbedded}
     * @memberof PagedModelEntityModelUser
     */
    '_embedded'?: PagedModelEntityModelUserEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelUser
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelUser
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUserEmbedded
 */
export interface PagedModelEntityModelUserEmbedded {
    /**
     * 
     * @type {Array<EntityModelUser>}
     * @memberof PagedModelEntityModelUserEmbedded
     */
    'users'?: Array<EntityModelUser>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUserWallet
 */
export interface PagedModelEntityModelUserWallet {
    /**
     * 
     * @type {PagedModelEntityModelUserWalletEmbedded}
     * @memberof PagedModelEntityModelUserWallet
     */
    '_embedded'?: PagedModelEntityModelUserWalletEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelUserWallet
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelUserWallet
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUserWalletEmbedded
 */
export interface PagedModelEntityModelUserWalletEmbedded {
    /**
     * 
     * @type {Array<EntityModelUserWallet>}
     * @memberof PagedModelEntityModelUserWalletEmbedded
     */
    'userWallets'?: Array<EntityModelUserWallet>;
}
/**
 * 
 * @export
 * @interface Pass
 */
export interface Pass {
    /**
     * 
     * @type {number}
     * @memberof Pass
     */
    'id'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pass
     */
    'pass'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PassRequestBody
 */
export interface PassRequestBody {
    /**
     * 
     * @type {number}
     * @memberof PassRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PassRequestBody
     */
    'pass'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentTypeRequestBody
 */
export interface PaymentTypeRequestBody {
    /**
     * 
     * @type {number}
     * @memberof PaymentTypeRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentTypeRequestBody
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTypeRequestBody
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentTypeRequestBody
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentTypeRequestBody
     */
    'cvv'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTypeRequestBody
     */
    'pan'?: string;
}
/**
 * 
 * @export
 * @interface RefreshTokenDTO
 */
export interface RefreshTokenDTO {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenDTO
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface RepresentationModelObject
 */
export interface RepresentationModelObject {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof RepresentationModelObject
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface SignInDTO
 */
export interface SignInDTO {
    /**
     * 
     * @type {string}
     * @memberof SignInDTO
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignInDTO
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface SignUpDTO
 */
export interface SignUpDTO {
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'role': SignUpDTORoleEnum;
}

export const SignUpDTORoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type SignUpDTORoleEnum = typeof SignUpDTORoleEnum[keyof typeof SignUpDTORoleEnum];

/**
 * 
 * @export
 * @interface TicketRequestBody
 */
export interface TicketRequestBody {
    /**
     * 
     * @type {number}
     * @memberof TicketRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof TicketRequestBody
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof TicketRequestBody
     */
    'price'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TicketRequestBody
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenRequestBody
 */
export interface TokenRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof TokenRequestBody
     */
    'revoked'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TokenRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TokenRequestBody
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequestBody
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequestBody
     */
    'expiryDate'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {UserWallet}
     * @memberof User
     */
    'wallet'?: UserWallet;
    /**
     * 
     * @type {Pass}
     * @memberof User
     */
    'pass'?: Pass;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role'?: UserRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'accountNonLocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'accountNonExpired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'credentialsNonExpired'?: boolean;
    /**
     * 
     * @type {Array<GrantedAuthority>}
     * @memberof User
     */
    'authorities'?: Array<GrantedAuthority>;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'deleted'?: boolean;
}

export const UserRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * 
 * @export
 * @interface UserRequestBody
 */
export interface UserRequestBody {
    /**
     * 
     * @type {number}
     * @memberof UserRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'wallet'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'pass'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'role'?: UserRequestBodyRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'accountNonLocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'username'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'accountNonExpired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'credentialsNonExpired'?: boolean;
    /**
     * 
     * @type {Array<GrantedAuthority>}
     * @memberof UserRequestBody
     */
    'authorities'?: Array<GrantedAuthority>;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'deleted'?: boolean;
}

export const UserRequestBodyRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserRequestBodyRoleEnum = typeof UserRequestBodyRoleEnum[keyof typeof UserRequestBodyRoleEnum];

/**
 * 
 * @export
 * @interface UserWallet
 */
export interface UserWallet {
    /**
     * 
     * @type {number}
     * @memberof UserWallet
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWallet
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserWallet
     */
    'memberShipEnds'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserWallet
     */
    'membershipActive'?: boolean;
}
/**
 * 
 * @export
 * @interface UserWalletRequestBody
 */
export interface UserWalletRequestBody {
    /**
     * 
     * @type {number}
     * @memberof UserWalletRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWalletRequestBody
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserWalletRequestBody
     */
    'memberShipEnds'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserWalletRequestBody
     */
    'membershipActive'?: boolean;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Logs a user in by an email and password. Returns a JWT token for session handling.
         * @param {SignInDTO} signInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (signInDTO: SignInDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInDTO' is not null or undefined
            assertParamExists('authenticate', 'signInDTO', signInDTO)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if the access token is valid.
         * @param {IsLoggedInDTO} dto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isLogged: async (dto: IsLoggedInDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dto' is not null or undefined
            assertParamExists('isLogged', 'dto', dto)
            const localVarPath = `/auth/isLogged`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dto !== undefined) {
                for (const [key, value] of Object.entries(dto)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if the refresh token is valid.
         * @param {RefreshTokenDTO} dto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRefreshTokenExpired: async (dto: RefreshTokenDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dto' is not null or undefined
            assertParamExists('isRefreshTokenExpired', 'dto', dto)
            const localVarPath = `/auth/check-refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dto !== undefined) {
                for (const [key, value] of Object.entries(dto)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This method handles user logout. It removes the refresh token associated with the user (if it exists).
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (refreshToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('logout', 'refreshToken', refreshToken)
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refreshToken !== undefined) {
                localVarQueryParameter['refreshToken'] = refreshToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to refresh expired access token. Verifies if refresh token is valid.
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken: async (refreshToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('refreshAccessToken', 'refreshToken', refreshToken)
            const localVarPath = `/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refreshToken !== undefined) {
                localVarQueryParameter['refreshToken'] = refreshToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upon successful registration, it returns JWT and refresh token cookies, similar to the login process. This allows the user to immediately log in after signing up.
         * @param {SignUpDTO} signUpDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (signUpDTO: SignUpDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpDTO' is not null or undefined
            assertParamExists('register', 'signUpDTO', signUpDTO)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Logs a user in by an email and password. Returns a JWT token for session handling.
         * @param {SignInDTO} signInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(signInDTO: SignInDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(signInDTO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Checks if the access token is valid.
         * @param {IsLoggedInDTO} dto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isLogged(dto: IsLoggedInDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isLogged(dto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.isLogged']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Checks if the refresh token is valid.
         * @param {RefreshTokenDTO} dto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isRefreshTokenExpired(dto: RefreshTokenDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isRefreshTokenExpired(dto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.isRefreshTokenExpired']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary This method handles user logout. It removes the refresh token associated with the user (if it exists).
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(refreshToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(refreshToken, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.logout']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Used to refresh expired access token. Verifies if refresh token is valid.
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAccessToken(refreshToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(refreshToken, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.refreshAccessToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Upon successful registration, it returns JWT and refresh token cookies, similar to the login process. This allows the user to immediately log in after signing up.
         * @param {SignUpDTO} signUpDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(signUpDTO: SignUpDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(signUpDTO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.register']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Logs a user in by an email and password. Returns a JWT token for session handling.
         * @param {SignInDTO} signInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(signInDTO: SignInDTO, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.authenticate(signInDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Checks if the access token is valid.
         * @param {IsLoggedInDTO} dto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isLogged(dto: IsLoggedInDTO, options?: any): AxiosPromise<boolean> {
            return localVarFp.isLogged(dto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Checks if the refresh token is valid.
         * @param {RefreshTokenDTO} dto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRefreshTokenExpired(dto: RefreshTokenDTO, options?: any): AxiosPromise<boolean> {
            return localVarFp.isRefreshTokenExpired(dto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This method handles user logout. It removes the refresh token associated with the user (if it exists).
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(refreshToken: string, options?: any): AxiosPromise<void> {
            return localVarFp.logout(refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to refresh expired access token. Verifies if refresh token is valid.
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(refreshToken: string, options?: any): AxiosPromise<string> {
            return localVarFp.refreshAccessToken(refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upon successful registration, it returns JWT and refresh token cookies, similar to the login process. This allows the user to immediately log in after signing up.
         * @param {SignUpDTO} signUpDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(signUpDTO: SignUpDTO, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.register(signUpDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Logs a user in by an email and password. Returns a JWT token for session handling.
     * @param {SignInDTO} signInDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticate(signInDTO: SignInDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticate(signInDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Checks if the access token is valid.
     * @param {IsLoggedInDTO} dto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public isLogged(dto: IsLoggedInDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).isLogged(dto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Checks if the refresh token is valid.
     * @param {RefreshTokenDTO} dto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public isRefreshTokenExpired(dto: RefreshTokenDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).isRefreshTokenExpired(dto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This method handles user logout. It removes the refresh token associated with the user (if it exists).
     * @param {string} refreshToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(refreshToken: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to refresh expired access token. Verifies if refresh token is valid.
     * @param {string} refreshToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public refreshAccessToken(refreshToken: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refreshAccessToken(refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upon successful registration, it returns JWT and refresh token cookies, similar to the login process. This allows the user to immediately log in after signing up.
     * @param {SignUpDTO} signUpDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public register(signUpDTO: SignUpDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).register(signUpDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembershipEntityControllerApi - axios parameter creator
 * @export
 */
export const MembershipEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceMembershipDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceMembershipDelete', 'id', id)
            const localVarPath = `/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-membership
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceMembershipGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceMembershipGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceMembershipGet', 'id', id)
            const localVarPath = `/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceMembershipPatch: async (id: string, membershipRequestBody: MembershipRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceMembershipPatch', 'id', id)
            // verify required parameter 'membershipRequestBody' is not null or undefined
            assertParamExists('patchItemResourceMembershipPatch', 'membershipRequestBody', membershipRequestBody)
            const localVarPath = `/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membershipRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-membership
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceMembershipPost: async (membershipRequestBody: MembershipRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'membershipRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceMembershipPost', 'membershipRequestBody', membershipRequestBody)
            const localVarPath = `/memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membershipRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceMembershipPut: async (id: string, membershipRequestBody: MembershipRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceMembershipPut', 'id', id)
            // verify required parameter 'membershipRequestBody' is not null or undefined
            assertParamExists('putItemResourceMembershipPut', 'membershipRequestBody', membershipRequestBody)
            const localVarPath = `/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membershipRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembershipEntityControllerApi - functional programming interface
 * @export
 */
export const MembershipEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembershipEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceMembershipDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceMembershipDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.deleteItemResourceMembershipDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-membership
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceMembershipGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceMembershipGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.getCollectionResourceMembershipGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceMembershipGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceMembershipGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.getItemResourceMembershipGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceMembershipPatch(id: string, membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceMembershipPatch(id, membershipRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.patchItemResourceMembershipPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-membership
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceMembershipPost(membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceMembershipPost(membershipRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.postCollectionResourceMembershipPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceMembershipPut(id: string, membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceMembershipPut(id, membershipRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.putItemResourceMembershipPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MembershipEntityControllerApi - factory interface
 * @export
 */
export const MembershipEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembershipEntityControllerApiFp(configuration)
    return {
        /**
         * delete-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceMembershipDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceMembershipDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-membership
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceMembershipGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelMembership> {
            return localVarFp.getCollectionResourceMembershipGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceMembershipGet(id: string, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.getItemResourceMembershipGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceMembershipPatch(id: string, membershipRequestBody: MembershipRequestBody, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.patchItemResourceMembershipPatch(id, membershipRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-membership
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceMembershipPost(membershipRequestBody: MembershipRequestBody, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.postCollectionResourceMembershipPost(membershipRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceMembershipPut(id: string, membershipRequestBody: MembershipRequestBody, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.putItemResourceMembershipPut(id, membershipRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembershipEntityControllerApi - object-oriented interface
 * @export
 * @class MembershipEntityControllerApi
 * @extends {BaseAPI}
 */
export class MembershipEntityControllerApi extends BaseAPI {
    /**
     * delete-membership
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public deleteItemResourceMembershipDelete(id: string, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).deleteItemResourceMembershipDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-membership
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public getCollectionResourceMembershipGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).getCollectionResourceMembershipGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-membership
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public getItemResourceMembershipGet(id: string, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).getItemResourceMembershipGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-membership
     * @param {string} id 
     * @param {MembershipRequestBody} membershipRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public patchItemResourceMembershipPatch(id: string, membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).patchItemResourceMembershipPatch(id, membershipRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-membership
     * @param {MembershipRequestBody} membershipRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public postCollectionResourceMembershipPost(membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).postCollectionResourceMembershipPost(membershipRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-membership
     * @param {string} id 
     * @param {MembershipRequestBody} membershipRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public putItemResourceMembershipPut(id: string, membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).putItemResourceMembershipPut(id, membershipRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembershipSearchControllerApi - axios parameter creator
 * @export
 */
export const MembershipSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchMembershipGet: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/memberships/search/getMembershipById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembershipSearchControllerApi - functional programming interface
 * @export
 */
export const MembershipSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembershipSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchMembershipGet(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchMembershipGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipSearchControllerApi.executeSearchMembershipGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MembershipSearchControllerApi - factory interface
 * @export
 */
export const MembershipSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembershipSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchMembershipGet(id?: number, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.executeSearchMembershipGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembershipSearchControllerApi - object-oriented interface
 * @export
 * @class MembershipSearchControllerApi
 * @extends {BaseAPI}
 */
export class MembershipSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipSearchControllerApi
     */
    public executeSearchMembershipGet(id?: number, options?: RawAxiosRequestConfig) {
        return MembershipSearchControllerApiFp(this.configuration).executeSearchMembershipGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PassEntityControllerApi - axios parameter creator
 * @export
 */
export const PassEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourcePassDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourcePassDelete', 'id', id)
            const localVarPath = `/passes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-pass
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourcePassGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/passes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourcePassGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourcePassGet', 'id', id)
            const localVarPath = `/passes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourcePassPatch: async (id: string, passRequestBody: PassRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourcePassPatch', 'id', id)
            // verify required parameter 'passRequestBody' is not null or undefined
            assertParamExists('patchItemResourcePassPatch', 'passRequestBody', passRequestBody)
            const localVarPath = `/passes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-pass
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourcePassPost: async (passRequestBody: PassRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passRequestBody' is not null or undefined
            assertParamExists('postCollectionResourcePassPost', 'passRequestBody', passRequestBody)
            const localVarPath = `/passes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourcePassPut: async (id: string, passRequestBody: PassRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourcePassPut', 'id', id)
            // verify required parameter 'passRequestBody' is not null or undefined
            assertParamExists('putItemResourcePassPut', 'passRequestBody', passRequestBody)
            const localVarPath = `/passes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PassEntityControllerApi - functional programming interface
 * @export
 */
export const PassEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PassEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourcePassDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourcePassDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.deleteItemResourcePassDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-pass
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourcePassGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourcePassGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.getCollectionResourcePassGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourcePassGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourcePassGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.getItemResourcePassGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourcePassPatch(id: string, passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourcePassPatch(id, passRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.patchItemResourcePassPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-pass
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourcePassPost(passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourcePassPost(passRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.postCollectionResourcePassPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourcePassPut(id: string, passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourcePassPut(id, passRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.putItemResourcePassPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PassEntityControllerApi - factory interface
 * @export
 */
export const PassEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PassEntityControllerApiFp(configuration)
    return {
        /**
         * delete-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourcePassDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourcePassDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-pass
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourcePassGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelPass> {
            return localVarFp.getCollectionResourcePassGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourcePassGet(id: string, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.getItemResourcePassGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourcePassPatch(id: string, passRequestBody: PassRequestBody, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.patchItemResourcePassPatch(id, passRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-pass
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourcePassPost(passRequestBody: PassRequestBody, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.postCollectionResourcePassPost(passRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourcePassPut(id: string, passRequestBody: PassRequestBody, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.putItemResourcePassPut(id, passRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PassEntityControllerApi - object-oriented interface
 * @export
 * @class PassEntityControllerApi
 * @extends {BaseAPI}
 */
export class PassEntityControllerApi extends BaseAPI {
    /**
     * delete-pass
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public deleteItemResourcePassDelete(id: string, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).deleteItemResourcePassDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-pass
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public getCollectionResourcePassGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).getCollectionResourcePassGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-pass
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public getItemResourcePassGet(id: string, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).getItemResourcePassGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-pass
     * @param {string} id 
     * @param {PassRequestBody} passRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public patchItemResourcePassPatch(id: string, passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).patchItemResourcePassPatch(id, passRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-pass
     * @param {PassRequestBody} passRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public postCollectionResourcePassPost(passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).postCollectionResourcePassPost(passRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-pass
     * @param {string} id 
     * @param {PassRequestBody} passRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public putItemResourcePassPut(id: string, passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).putItemResourcePassPut(id, passRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PassSearchControllerApi - axios parameter creator
 * @export
 */
export const PassSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchPassGet: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/passes/search/getPassById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PassSearchControllerApi - functional programming interface
 * @export
 */
export const PassSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PassSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchPassGet(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchPassGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassSearchControllerApi.executeSearchPassGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PassSearchControllerApi - factory interface
 * @export
 */
export const PassSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PassSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchPassGet(id?: number, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.executeSearchPassGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PassSearchControllerApi - object-oriented interface
 * @export
 * @class PassSearchControllerApi
 * @extends {BaseAPI}
 */
export class PassSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassSearchControllerApi
     */
    public executeSearchPassGet(id?: number, options?: RawAxiosRequestConfig) {
        return PassSearchControllerApiFp(this.configuration).executeSearchPassGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentTypeEntityControllerApi - axios parameter creator
 * @export
 */
export const PaymentTypeEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-paymenttype
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourcePaymenttypeDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourcePaymenttypeDelete', 'id', id)
            const localVarPath = `/paymentTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-paymenttype
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourcePaymenttypeGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/paymentTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-paymenttype
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourcePaymenttypeGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourcePaymenttypeGet', 'id', id)
            const localVarPath = `/paymentTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-paymenttype
         * @param {string} id 
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourcePaymenttypePatch: async (id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourcePaymenttypePatch', 'id', id)
            // verify required parameter 'paymentTypeRequestBody' is not null or undefined
            assertParamExists('patchItemResourcePaymenttypePatch', 'paymentTypeRequestBody', paymentTypeRequestBody)
            const localVarPath = `/paymentTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentTypeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-paymenttype
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourcePaymenttypePost: async (paymentTypeRequestBody: PaymentTypeRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentTypeRequestBody' is not null or undefined
            assertParamExists('postCollectionResourcePaymenttypePost', 'paymentTypeRequestBody', paymentTypeRequestBody)
            const localVarPath = `/paymentTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentTypeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-paymenttype
         * @param {string} id 
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourcePaymenttypePut: async (id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourcePaymenttypePut', 'id', id)
            // verify required parameter 'paymentTypeRequestBody' is not null or undefined
            assertParamExists('putItemResourcePaymenttypePut', 'paymentTypeRequestBody', paymentTypeRequestBody)
            const localVarPath = `/paymentTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentTypeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentTypeEntityControllerApi - functional programming interface
 * @export
 */
export const PaymentTypeEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentTypeEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-paymenttype
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourcePaymenttypeDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourcePaymenttypeDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeEntityControllerApi.deleteItemResourcePaymenttypeDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-paymenttype
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourcePaymenttypeGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelPaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourcePaymenttypeGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeEntityControllerApi.getCollectionResourcePaymenttypeGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-paymenttype
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourcePaymenttypeGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourcePaymenttypeGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeEntityControllerApi.getItemResourcePaymenttypeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-paymenttype
         * @param {string} id 
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourcePaymenttypePatch(id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourcePaymenttypePatch(id, paymentTypeRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeEntityControllerApi.patchItemResourcePaymenttypePatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-paymenttype
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourcePaymenttypePost(paymentTypeRequestBody: PaymentTypeRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourcePaymenttypePost(paymentTypeRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeEntityControllerApi.postCollectionResourcePaymenttypePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-paymenttype
         * @param {string} id 
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourcePaymenttypePut(id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourcePaymenttypePut(id, paymentTypeRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeEntityControllerApi.putItemResourcePaymenttypePut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PaymentTypeEntityControllerApi - factory interface
 * @export
 */
export const PaymentTypeEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentTypeEntityControllerApiFp(configuration)
    return {
        /**
         * delete-paymenttype
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourcePaymenttypeDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourcePaymenttypeDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-paymenttype
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourcePaymenttypeGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelPaymentType> {
            return localVarFp.getCollectionResourcePaymenttypeGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-paymenttype
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourcePaymenttypeGet(id: string, options?: any): AxiosPromise<EntityModelPaymentType> {
            return localVarFp.getItemResourcePaymenttypeGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-paymenttype
         * @param {string} id 
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourcePaymenttypePatch(id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options?: any): AxiosPromise<EntityModelPaymentType> {
            return localVarFp.patchItemResourcePaymenttypePatch(id, paymentTypeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-paymenttype
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourcePaymenttypePost(paymentTypeRequestBody: PaymentTypeRequestBody, options?: any): AxiosPromise<EntityModelPaymentType> {
            return localVarFp.postCollectionResourcePaymenttypePost(paymentTypeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-paymenttype
         * @param {string} id 
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourcePaymenttypePut(id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options?: any): AxiosPromise<EntityModelPaymentType> {
            return localVarFp.putItemResourcePaymenttypePut(id, paymentTypeRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentTypeEntityControllerApi - object-oriented interface
 * @export
 * @class PaymentTypeEntityControllerApi
 * @extends {BaseAPI}
 */
export class PaymentTypeEntityControllerApi extends BaseAPI {
    /**
     * delete-paymenttype
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeEntityControllerApi
     */
    public deleteItemResourcePaymenttypeDelete(id: string, options?: RawAxiosRequestConfig) {
        return PaymentTypeEntityControllerApiFp(this.configuration).deleteItemResourcePaymenttypeDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-paymenttype
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeEntityControllerApi
     */
    public getCollectionResourcePaymenttypeGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return PaymentTypeEntityControllerApiFp(this.configuration).getCollectionResourcePaymenttypeGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-paymenttype
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeEntityControllerApi
     */
    public getItemResourcePaymenttypeGet(id: string, options?: RawAxiosRequestConfig) {
        return PaymentTypeEntityControllerApiFp(this.configuration).getItemResourcePaymenttypeGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-paymenttype
     * @param {string} id 
     * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeEntityControllerApi
     */
    public patchItemResourcePaymenttypePatch(id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options?: RawAxiosRequestConfig) {
        return PaymentTypeEntityControllerApiFp(this.configuration).patchItemResourcePaymenttypePatch(id, paymentTypeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-paymenttype
     * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeEntityControllerApi
     */
    public postCollectionResourcePaymenttypePost(paymentTypeRequestBody: PaymentTypeRequestBody, options?: RawAxiosRequestConfig) {
        return PaymentTypeEntityControllerApiFp(this.configuration).postCollectionResourcePaymenttypePost(paymentTypeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-paymenttype
     * @param {string} id 
     * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeEntityControllerApi
     */
    public putItemResourcePaymenttypePut(id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options?: RawAxiosRequestConfig) {
        return PaymentTypeEntityControllerApiFp(this.configuration).putItemResourcePaymenttypePut(id, paymentTypeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentTypePropertyReferenceControllerApi - axios parameter creator
 * @export
 */
export const PaymentTypePropertyReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * patch-user-by-paymenttype-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferencePaymenttypePatch: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferencePaymenttypePatch', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferencePaymenttypePatch', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/paymentTypes/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-user-by-paymenttype-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferencePaymenttypePut: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferencePaymenttypePut', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferencePaymenttypePut', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/paymentTypes/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-user-by-paymenttype-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdPaymenttypeDelete: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdPaymenttypeDelete', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdPaymenttypeDelete', 'propertyId', propertyId)
            const localVarPath = `/paymentTypes/{id}/user/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-user-by-paymenttype-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferencePaymenttypeDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferencePaymenttypeDelete', 'id', id)
            const localVarPath = `/paymentTypes/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user-by-paymenttype-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferencePaymenttypeGet: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferencePaymenttypeGet', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferencePaymenttypeGet', 'propertyId', propertyId)
            const localVarPath = `/paymentTypes/{id}/user/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user-by-paymenttype-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferencePaymenttypeGet1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferencePaymenttypeGet1', 'id', id)
            const localVarPath = `/paymentTypes/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentTypePropertyReferenceControllerApi - functional programming interface
 * @export
 */
export const PaymentTypePropertyReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentTypePropertyReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * patch-user-by-paymenttype-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferencePaymenttypePatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferencePaymenttypePatch(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypePropertyReferenceControllerApi.createPropertyReferencePaymenttypePatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-user-by-paymenttype-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferencePaymenttypePut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferencePaymenttypePut(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypePropertyReferenceControllerApi.createPropertyReferencePaymenttypePut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-user-by-paymenttype-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdPaymenttypeDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdPaymenttypeDelete(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypePropertyReferenceControllerApi.deletePropertyReferenceIdPaymenttypeDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-user-by-paymenttype-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferencePaymenttypeDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferencePaymenttypeDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypePropertyReferenceControllerApi.deletePropertyReferencePaymenttypeDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user-by-paymenttype-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferencePaymenttypeGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferencePaymenttypeGet(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypePropertyReferenceControllerApi.followPropertyReferencePaymenttypeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user-by-paymenttype-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferencePaymenttypeGet1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferencePaymenttypeGet1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypePropertyReferenceControllerApi.followPropertyReferencePaymenttypeGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PaymentTypePropertyReferenceControllerApi - factory interface
 * @export
 */
export const PaymentTypePropertyReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentTypePropertyReferenceControllerApiFp(configuration)
    return {
        /**
         * patch-user-by-paymenttype-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferencePaymenttypePatch(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.createPropertyReferencePaymenttypePatch(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-user-by-paymenttype-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferencePaymenttypePut(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.createPropertyReferencePaymenttypePut(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-user-by-paymenttype-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdPaymenttypeDelete(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdPaymenttypeDelete(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-user-by-paymenttype-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferencePaymenttypeDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferencePaymenttypeDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user-by-paymenttype-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferencePaymenttypeGet(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.followPropertyReferencePaymenttypeGet(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user-by-paymenttype-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferencePaymenttypeGet1(id: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.followPropertyReferencePaymenttypeGet1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentTypePropertyReferenceControllerApi - object-oriented interface
 * @export
 * @class PaymentTypePropertyReferenceControllerApi
 * @extends {BaseAPI}
 */
export class PaymentTypePropertyReferenceControllerApi extends BaseAPI {
    /**
     * patch-user-by-paymenttype-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypePropertyReferenceControllerApi
     */
    public createPropertyReferencePaymenttypePatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return PaymentTypePropertyReferenceControllerApiFp(this.configuration).createPropertyReferencePaymenttypePatch(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-user-by-paymenttype-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypePropertyReferenceControllerApi
     */
    public createPropertyReferencePaymenttypePut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return PaymentTypePropertyReferenceControllerApiFp(this.configuration).createPropertyReferencePaymenttypePut(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-user-by-paymenttype-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypePropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdPaymenttypeDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return PaymentTypePropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdPaymenttypeDelete(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-user-by-paymenttype-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypePropertyReferenceControllerApi
     */
    public deletePropertyReferencePaymenttypeDelete(id: string, options?: RawAxiosRequestConfig) {
        return PaymentTypePropertyReferenceControllerApiFp(this.configuration).deletePropertyReferencePaymenttypeDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user-by-paymenttype-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypePropertyReferenceControllerApi
     */
    public followPropertyReferencePaymenttypeGet(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return PaymentTypePropertyReferenceControllerApiFp(this.configuration).followPropertyReferencePaymenttypeGet(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user-by-paymenttype-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypePropertyReferenceControllerApi
     */
    public followPropertyReferencePaymenttypeGet1(id: string, options?: RawAxiosRequestConfig) {
        return PaymentTypePropertyReferenceControllerApiFp(this.configuration).followPropertyReferencePaymenttypeGet1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentTypeSearchControllerApi - axios parameter creator
 * @export
 */
export const PaymentTypeSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchPaymenttypeGet: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/paymentTypes/search/getPaymentTypeById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentTypeSearchControllerApi - functional programming interface
 * @export
 */
export const PaymentTypeSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentTypeSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchPaymenttypeGet(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchPaymenttypeGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeSearchControllerApi.executeSearchPaymenttypeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PaymentTypeSearchControllerApi - factory interface
 * @export
 */
export const PaymentTypeSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentTypeSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchPaymenttypeGet(id?: number, options?: any): AxiosPromise<EntityModelPaymentType> {
            return localVarFp.executeSearchPaymenttypeGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentTypeSearchControllerApi - object-oriented interface
 * @export
 * @class PaymentTypeSearchControllerApi
 * @extends {BaseAPI}
 */
export class PaymentTypeSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeSearchControllerApi
     */
    public executeSearchPaymenttypeGet(id?: number, options?: RawAxiosRequestConfig) {
        return PaymentTypeSearchControllerApiFp(this.configuration).executeSearchPaymenttypeGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileControllerApi - axios parameter creator
 * @export
 */
export const ProfileControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor111: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor112: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/passes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor113: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/paymentTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor114: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor115: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor116: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/userWallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor117: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFormsOfMetadata1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileControllerApi - functional programming interface
 * @export
 */
export const ProfileControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor111(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor111(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor111']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor112(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor112(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor112']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor113(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor113(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor113']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor114(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor114(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor114']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor115(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor115(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor115']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor116(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor116(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor116']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor117(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor117(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor117']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllFormsOfMetadata1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepresentationModelObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllFormsOfMetadata1(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.listAllFormsOfMetadata1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProfileControllerApi - factory interface
 * @export
 */
export const ProfileControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor111(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor111(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor112(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor112(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor113(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor113(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor114(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor114(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor115(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor115(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor116(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor116(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor117(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor117(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFormsOfMetadata1(options?: any): AxiosPromise<RepresentationModelObject> {
            return localVarFp.listAllFormsOfMetadata1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileControllerApi - object-oriented interface
 * @export
 * @class ProfileControllerApi
 * @extends {BaseAPI}
 */
export class ProfileControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor111(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor111(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor112(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor112(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor113(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor113(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor114(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor114(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor115(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor115(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor116(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor116(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor117(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor117(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public listAllFormsOfMetadata1(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).listAllFormsOfMetadata1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TicketEntityControllerApi - axios parameter creator
 * @export
 */
export const TicketEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceTicketDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceTicketDelete', 'id', id)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-ticket
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceTicketGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceTicketGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceTicketGet', 'id', id)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceTicketPatch: async (id: string, ticketRequestBody: TicketRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceTicketPatch', 'id', id)
            // verify required parameter 'ticketRequestBody' is not null or undefined
            assertParamExists('patchItemResourceTicketPatch', 'ticketRequestBody', ticketRequestBody)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-ticket
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceTicketPost: async (ticketRequestBody: TicketRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceTicketPost', 'ticketRequestBody', ticketRequestBody)
            const localVarPath = `/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceTicketPut: async (id: string, ticketRequestBody: TicketRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceTicketPut', 'id', id)
            // verify required parameter 'ticketRequestBody' is not null or undefined
            assertParamExists('putItemResourceTicketPut', 'ticketRequestBody', ticketRequestBody)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TicketEntityControllerApi - functional programming interface
 * @export
 */
export const TicketEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TicketEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceTicketDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceTicketDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.deleteItemResourceTicketDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-ticket
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceTicketGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceTicketGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.getCollectionResourceTicketGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceTicketGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceTicketGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.getItemResourceTicketGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceTicketPatch(id: string, ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceTicketPatch(id, ticketRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.patchItemResourceTicketPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-ticket
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceTicketPost(ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceTicketPost(ticketRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.postCollectionResourceTicketPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceTicketPut(id: string, ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceTicketPut(id, ticketRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.putItemResourceTicketPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TicketEntityControllerApi - factory interface
 * @export
 */
export const TicketEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TicketEntityControllerApiFp(configuration)
    return {
        /**
         * delete-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceTicketDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceTicketDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-ticket
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceTicketGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelTicket> {
            return localVarFp.getCollectionResourceTicketGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceTicketGet(id: string, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.getItemResourceTicketGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceTicketPatch(id: string, ticketRequestBody: TicketRequestBody, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.patchItemResourceTicketPatch(id, ticketRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-ticket
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceTicketPost(ticketRequestBody: TicketRequestBody, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.postCollectionResourceTicketPost(ticketRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceTicketPut(id: string, ticketRequestBody: TicketRequestBody, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.putItemResourceTicketPut(id, ticketRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TicketEntityControllerApi - object-oriented interface
 * @export
 * @class TicketEntityControllerApi
 * @extends {BaseAPI}
 */
export class TicketEntityControllerApi extends BaseAPI {
    /**
     * delete-ticket
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public deleteItemResourceTicketDelete(id: string, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).deleteItemResourceTicketDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-ticket
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public getCollectionResourceTicketGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).getCollectionResourceTicketGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-ticket
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public getItemResourceTicketGet(id: string, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).getItemResourceTicketGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-ticket
     * @param {string} id 
     * @param {TicketRequestBody} ticketRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public patchItemResourceTicketPatch(id: string, ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).patchItemResourceTicketPatch(id, ticketRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-ticket
     * @param {TicketRequestBody} ticketRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public postCollectionResourceTicketPost(ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).postCollectionResourceTicketPost(ticketRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-ticket
     * @param {string} id 
     * @param {TicketRequestBody} ticketRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public putItemResourceTicketPut(id: string, ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).putItemResourceTicketPut(id, ticketRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TicketSearchControllerApi - axios parameter creator
 * @export
 */
export const TicketSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTicketGet: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tickets/search/getTicketById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TicketSearchControllerApi - functional programming interface
 * @export
 */
export const TicketSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TicketSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchTicketGet(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchTicketGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketSearchControllerApi.executeSearchTicketGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TicketSearchControllerApi - factory interface
 * @export
 */
export const TicketSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TicketSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTicketGet(id?: number, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.executeSearchTicketGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TicketSearchControllerApi - object-oriented interface
 * @export
 * @class TicketSearchControllerApi
 * @extends {BaseAPI}
 */
export class TicketSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketSearchControllerApi
     */
    public executeSearchTicketGet(id?: number, options?: RawAxiosRequestConfig) {
        return TicketSearchControllerApiFp(this.configuration).executeSearchTicketGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokenEntityControllerApi - axios parameter creator
 * @export
 */
export const TokenEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceTokenDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceTokenDelete', 'id', id)
            const localVarPath = `/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-token
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceTokenGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceTokenGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceTokenGet', 'id', id)
            const localVarPath = `/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceTokenPatch: async (id: string, tokenRequestBody: TokenRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceTokenPatch', 'id', id)
            // verify required parameter 'tokenRequestBody' is not null or undefined
            assertParamExists('patchItemResourceTokenPatch', 'tokenRequestBody', tokenRequestBody)
            const localVarPath = `/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-token
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceTokenPost: async (tokenRequestBody: TokenRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceTokenPost', 'tokenRequestBody', tokenRequestBody)
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceTokenPut: async (id: string, tokenRequestBody: TokenRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceTokenPut', 'id', id)
            // verify required parameter 'tokenRequestBody' is not null or undefined
            assertParamExists('putItemResourceTokenPut', 'tokenRequestBody', tokenRequestBody)
            const localVarPath = `/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenEntityControllerApi - functional programming interface
 * @export
 */
export const TokenEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceTokenDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceTokenDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.deleteItemResourceTokenDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-token
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceTokenGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceTokenGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.getCollectionResourceTokenGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceTokenGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceTokenGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.getItemResourceTokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceTokenPatch(id: string, tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceTokenPatch(id, tokenRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.patchItemResourceTokenPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-token
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceTokenPost(tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceTokenPost(tokenRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.postCollectionResourceTokenPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceTokenPut(id: string, tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceTokenPut(id, tokenRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.putItemResourceTokenPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TokenEntityControllerApi - factory interface
 * @export
 */
export const TokenEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenEntityControllerApiFp(configuration)
    return {
        /**
         * delete-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceTokenDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceTokenDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-token
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceTokenGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelToken> {
            return localVarFp.getCollectionResourceTokenGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceTokenGet(id: string, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.getItemResourceTokenGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceTokenPatch(id: string, tokenRequestBody: TokenRequestBody, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.patchItemResourceTokenPatch(id, tokenRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-token
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceTokenPost(tokenRequestBody: TokenRequestBody, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.postCollectionResourceTokenPost(tokenRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceTokenPut(id: string, tokenRequestBody: TokenRequestBody, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.putItemResourceTokenPut(id, tokenRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenEntityControllerApi - object-oriented interface
 * @export
 * @class TokenEntityControllerApi
 * @extends {BaseAPI}
 */
export class TokenEntityControllerApi extends BaseAPI {
    /**
     * delete-token
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public deleteItemResourceTokenDelete(id: string, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).deleteItemResourceTokenDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-token
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public getCollectionResourceTokenGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).getCollectionResourceTokenGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-token
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public getItemResourceTokenGet(id: string, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).getItemResourceTokenGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-token
     * @param {string} id 
     * @param {TokenRequestBody} tokenRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public patchItemResourceTokenPatch(id: string, tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).patchItemResourceTokenPatch(id, tokenRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-token
     * @param {TokenRequestBody} tokenRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public postCollectionResourceTokenPost(tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).postCollectionResourceTokenPost(tokenRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-token
     * @param {string} id 
     * @param {TokenRequestBody} tokenRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public putItemResourceTokenPut(id: string, tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).putItemResourceTokenPut(id, tokenRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokenPropertyReferenceControllerApi - axios parameter creator
 * @export
 */
export const TokenPropertyReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * patch-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceTokenPatch: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceTokenPatch', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceTokenPatch', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/tokens/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceTokenPut: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceTokenPut', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceTokenPut', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/tokens/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdTokenDelete: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdTokenDelete', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdTokenDelete', 'propertyId', propertyId)
            const localVarPath = `/tokens/{id}/user/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceTokenDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceTokenDelete', 'id', id)
            const localVarPath = `/tokens/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceTokenGet: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceTokenGet', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceTokenGet', 'propertyId', propertyId)
            const localVarPath = `/tokens/{id}/user/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceTokenGet1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceTokenGet1', 'id', id)
            const localVarPath = `/tokens/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenPropertyReferenceControllerApi - functional programming interface
 * @export
 */
export const TokenPropertyReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenPropertyReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * patch-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceTokenPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceTokenPatch(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.createPropertyReferenceTokenPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceTokenPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceTokenPut(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.createPropertyReferenceTokenPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdTokenDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdTokenDelete(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.deletePropertyReferenceIdTokenDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceTokenDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceTokenDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.deletePropertyReferenceTokenDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceTokenGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceTokenGet(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.followPropertyReferenceTokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceTokenGet1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceTokenGet1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.followPropertyReferenceTokenGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TokenPropertyReferenceControllerApi - factory interface
 * @export
 */
export const TokenPropertyReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenPropertyReferenceControllerApiFp(configuration)
    return {
        /**
         * patch-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceTokenPatch(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.createPropertyReferenceTokenPatch(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceTokenPut(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.createPropertyReferenceTokenPut(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdTokenDelete(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdTokenDelete(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceTokenDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceTokenDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceTokenGet(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.followPropertyReferenceTokenGet(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceTokenGet1(id: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.followPropertyReferenceTokenGet1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenPropertyReferenceControllerApi - object-oriented interface
 * @export
 * @class TokenPropertyReferenceControllerApi
 * @extends {BaseAPI}
 */
export class TokenPropertyReferenceControllerApi extends BaseAPI {
    /**
     * patch-user-by-token-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public createPropertyReferenceTokenPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceTokenPatch(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-user-by-token-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public createPropertyReferenceTokenPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceTokenPut(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-user-by-token-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdTokenDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdTokenDelete(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-user-by-token-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public deletePropertyReferenceTokenDelete(id: string, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceTokenDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user-by-token-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public followPropertyReferenceTokenGet(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceTokenGet(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user-by-token-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public followPropertyReferenceTokenGet1(id: string, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceTokenGet1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokenSearchControllerApi - axios parameter creator
 * @export
 */
export const TokenSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTokenGet: async (token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens/search/findByToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTokenGet1: async (user?: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens/search/findByUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (user !== undefined) {
                for (const [key, value] of Object.entries(user)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenSearchControllerApi - functional programming interface
 * @export
 */
export const TokenSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchTokenGet(token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchTokenGet(token, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenSearchControllerApi.executeSearchTokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchTokenGet1(user?: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchTokenGet1(user, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenSearchControllerApi.executeSearchTokenGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TokenSearchControllerApi - factory interface
 * @export
 */
export const TokenSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTokenGet(token?: string, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.executeSearchTokenGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTokenGet1(user?: User, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.executeSearchTokenGet1(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenSearchControllerApi - object-oriented interface
 * @export
 * @class TokenSearchControllerApi
 * @extends {BaseAPI}
 */
export class TokenSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [token] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenSearchControllerApi
     */
    public executeSearchTokenGet(token?: string, options?: RawAxiosRequestConfig) {
        return TokenSearchControllerApiFp(this.configuration).executeSearchTokenGet(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenSearchControllerApi
     */
    public executeSearchTokenGet1(user?: User, options?: RawAxiosRequestConfig) {
        return TokenSearchControllerApiFp(this.configuration).executeSearchTokenGet1(user, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserControllerApi.getUserById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: number, options?: any): AxiosPromise<User> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @summary Gets a user\'s information by their ID.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserById(userId: number, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserEntityControllerApi - axios parameter creator
 * @export
 */
export const UserEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceUserDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceUserDelete', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceUserGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceUserGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceUserGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceUserPatch: async (id: string, userRequestBody: UserRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceUserPatch', 'id', id)
            // verify required parameter 'userRequestBody' is not null or undefined
            assertParamExists('patchItemResourceUserPatch', 'userRequestBody', userRequestBody)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-user
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceUserPost: async (userRequestBody: UserRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceUserPost', 'userRequestBody', userRequestBody)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceUserPut: async (id: string, userRequestBody: UserRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceUserPut', 'id', id)
            // verify required parameter 'userRequestBody' is not null or undefined
            assertParamExists('putItemResourceUserPut', 'userRequestBody', userRequestBody)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserEntityControllerApi - functional programming interface
 * @export
 */
export const UserEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceUserDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceUserDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.deleteItemResourceUserDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceUserGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceUserGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.getCollectionResourceUserGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceUserGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceUserGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.getItemResourceUserGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceUserPatch(id: string, userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceUserPatch(id, userRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.patchItemResourceUserPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-user
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceUserPost(userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceUserPost(userRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.postCollectionResourceUserPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceUserPut(id: string, userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceUserPut(id, userRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.putItemResourceUserPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserEntityControllerApi - factory interface
 * @export
 */
export const UserEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserEntityControllerApiFp(configuration)
    return {
        /**
         * delete-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceUserDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceUserDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceUserGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelUser> {
            return localVarFp.getCollectionResourceUserGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceUserGet(id: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.getItemResourceUserGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceUserPatch(id: string, userRequestBody: UserRequestBody, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.patchItemResourceUserPatch(id, userRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-user
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceUserPost(userRequestBody: UserRequestBody, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.postCollectionResourceUserPost(userRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceUserPut(id: string, userRequestBody: UserRequestBody, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.putItemResourceUserPut(id, userRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserEntityControllerApi - object-oriented interface
 * @export
 * @class UserEntityControllerApi
 * @extends {BaseAPI}
 */
export class UserEntityControllerApi extends BaseAPI {
    /**
     * delete-user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public deleteItemResourceUserDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).deleteItemResourceUserDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public getCollectionResourceUserGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).getCollectionResourceUserGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public getItemResourceUserGet(id: string, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).getItemResourceUserGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-user
     * @param {string} id 
     * @param {UserRequestBody} userRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public patchItemResourceUserPatch(id: string, userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).patchItemResourceUserPatch(id, userRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-user
     * @param {UserRequestBody} userRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public postCollectionResourceUserPost(userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).postCollectionResourceUserPost(userRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-user
     * @param {string} id 
     * @param {UserRequestBody} userRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public putItemResourceUserPut(id: string, userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).putItemResourceUserPut(id, userRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserPropertyReferenceControllerApi - axios parameter creator
 * @export
 */
export const UserPropertyReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * patch-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPatch: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserPatch', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserPatch', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/users/{id}/pass`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPatch1: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserPatch1', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserPatch1', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/users/{id}/wallet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPut: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserPut', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserPut', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/users/{id}/pass`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPut1: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserPut1', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserPut1', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/users/{id}/wallet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserDelete: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserDelete', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserDelete', 'propertyId', propertyId)
            const localVarPath = `/users/{id}/pass/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserDelete1: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserDelete1', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserDelete1', 'propertyId', propertyId)
            const localVarPath = `/users/{id}/wallet/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceUserDelete', 'id', id)
            const localVarPath = `/users/{id}/pass`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserDelete1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceUserDelete1', 'id', id)
            const localVarPath = `/users/{id}/wallet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet', 'propertyId', propertyId)
            const localVarPath = `/users/{id}/pass/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet1', 'id', id)
            const localVarPath = `/users/{id}/pass`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet2: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet2', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet2', 'propertyId', propertyId)
            const localVarPath = `/users/{id}/wallet/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet21: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet21', 'id', id)
            const localVarPath = `/users/{id}/wallet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPropertyReferenceControllerApi - functional programming interface
 * @export
 */
export const UserPropertyReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPropertyReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * patch-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserPatch(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.createPropertyReferenceUserPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserPatch1(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserPatch1(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.createPropertyReferenceUserPatch1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserPut(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.createPropertyReferenceUserPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserPut1(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserPut1(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.createPropertyReferenceUserPut1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdUserDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdUserDelete(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.deletePropertyReferenceIdUserDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdUserDelete1(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdUserDelete1(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.deletePropertyReferenceIdUserDelete1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceUserDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceUserDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.deletePropertyReferenceUserDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceUserDelete1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceUserDelete1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.deletePropertyReferenceUserDelete1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserGet(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.followPropertyReferenceUserGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserGet1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserGet1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.followPropertyReferenceUserGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserGet2(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserGet2(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.followPropertyReferenceUserGet2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserGet21(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserGet21(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.followPropertyReferenceUserGet21']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserPropertyReferenceControllerApi - factory interface
 * @export
 */
export const UserPropertyReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPropertyReferenceControllerApiFp(configuration)
    return {
        /**
         * patch-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPatch(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.createPropertyReferenceUserPatch(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPatch1(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.createPropertyReferenceUserPatch1(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPut(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.createPropertyReferenceUserPut(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPut1(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.createPropertyReferenceUserPut1(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserDelete(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdUserDelete(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserDelete1(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdUserDelete1(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceUserDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserDelete1(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceUserDelete1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.followPropertyReferenceUserGet(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet1(id: string, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.followPropertyReferenceUserGet1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet2(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.followPropertyReferenceUserGet2(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet21(id: string, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.followPropertyReferenceUserGet21(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPropertyReferenceControllerApi - object-oriented interface
 * @export
 * @class UserPropertyReferenceControllerApi
 * @extends {BaseAPI}
 */
export class UserPropertyReferenceControllerApi extends BaseAPI {
    /**
     * patch-pass-by-user-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserPatch(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-userwallet-by-user-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserPatch1(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserPatch1(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-pass-by-user-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserPut(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-userwallet-by-user-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserPut1(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserPut1(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-pass-by-user-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdUserDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdUserDelete(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-userwallet-by-user-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdUserDelete1(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdUserDelete1(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-pass-by-user-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public deletePropertyReferenceUserDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceUserDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-userwallet-by-user-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public deletePropertyReferenceUserDelete1(id: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceUserDelete1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-pass-by-user-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserGet(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserGet(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-pass-by-user-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserGet1(id: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserGet1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-userwallet-by-user-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserGet2(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserGet2(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-userwallet-by-user-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserGet21(id: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserGet21(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserSearchControllerApi - axios parameter creator
 * @export
 */
export const UserSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet: async (email?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/existsByEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet1: async (email?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/findByEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet2: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/getUserById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSearchControllerApi - functional programming interface
 * @export
 */
export const UserSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserGet(email?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserGet(email, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchControllerApi.executeSearchUserGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserGet1(email?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserGet1(email, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchControllerApi.executeSearchUserGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserGet2(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserGet2(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchControllerApi.executeSearchUserGet2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserSearchControllerApi - factory interface
 * @export
 */
export const UserSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet(email?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.executeSearchUserGet(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet1(email?: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.executeSearchUserGet1(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet2(id?: number, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.executeSearchUserGet2(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSearchControllerApi - object-oriented interface
 * @export
 * @class UserSearchControllerApi
 * @extends {BaseAPI}
 */
export class UserSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchControllerApi
     */
    public executeSearchUserGet(email?: string, options?: RawAxiosRequestConfig) {
        return UserSearchControllerApiFp(this.configuration).executeSearchUserGet(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchControllerApi
     */
    public executeSearchUserGet1(email?: string, options?: RawAxiosRequestConfig) {
        return UserSearchControllerApiFp(this.configuration).executeSearchUserGet1(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchControllerApi
     */
    public executeSearchUserGet2(id?: number, options?: RawAxiosRequestConfig) {
        return UserSearchControllerApiFp(this.configuration).executeSearchUserGet2(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserWalletEntityControllerApi - axios parameter creator
 * @export
 */
export const UserWalletEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceUserwalletDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceUserwalletDelete', 'id', id)
            const localVarPath = `/userWallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-userwallet
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceUserwalletGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userWallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceUserwalletGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceUserwalletGet', 'id', id)
            const localVarPath = `/userWallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceUserwalletPatch: async (id: string, userWalletRequestBody: UserWalletRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceUserwalletPatch', 'id', id)
            // verify required parameter 'userWalletRequestBody' is not null or undefined
            assertParamExists('patchItemResourceUserwalletPatch', 'userWalletRequestBody', userWalletRequestBody)
            const localVarPath = `/userWallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWalletRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-userwallet
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceUserwalletPost: async (userWalletRequestBody: UserWalletRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userWalletRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceUserwalletPost', 'userWalletRequestBody', userWalletRequestBody)
            const localVarPath = `/userWallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWalletRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceUserwalletPut: async (id: string, userWalletRequestBody: UserWalletRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceUserwalletPut', 'id', id)
            // verify required parameter 'userWalletRequestBody' is not null or undefined
            assertParamExists('putItemResourceUserwalletPut', 'userWalletRequestBody', userWalletRequestBody)
            const localVarPath = `/userWallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWalletRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserWalletEntityControllerApi - functional programming interface
 * @export
 */
export const UserWalletEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserWalletEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceUserwalletDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceUserwalletDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.deleteItemResourceUserwalletDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-userwallet
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceUserwalletGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceUserwalletGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.getCollectionResourceUserwalletGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceUserwalletGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceUserwalletGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.getItemResourceUserwalletGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceUserwalletPatch(id: string, userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceUserwalletPatch(id, userWalletRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.patchItemResourceUserwalletPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-userwallet
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceUserwalletPost(userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceUserwalletPost(userWalletRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.postCollectionResourceUserwalletPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceUserwalletPut(id: string, userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceUserwalletPut(id, userWalletRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.putItemResourceUserwalletPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserWalletEntityControllerApi - factory interface
 * @export
 */
export const UserWalletEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserWalletEntityControllerApiFp(configuration)
    return {
        /**
         * delete-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceUserwalletDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceUserwalletDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-userwallet
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceUserwalletGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelUserWallet> {
            return localVarFp.getCollectionResourceUserwalletGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceUserwalletGet(id: string, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.getItemResourceUserwalletGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceUserwalletPatch(id: string, userWalletRequestBody: UserWalletRequestBody, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.patchItemResourceUserwalletPatch(id, userWalletRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-userwallet
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceUserwalletPost(userWalletRequestBody: UserWalletRequestBody, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.postCollectionResourceUserwalletPost(userWalletRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceUserwalletPut(id: string, userWalletRequestBody: UserWalletRequestBody, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.putItemResourceUserwalletPut(id, userWalletRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserWalletEntityControllerApi - object-oriented interface
 * @export
 * @class UserWalletEntityControllerApi
 * @extends {BaseAPI}
 */
export class UserWalletEntityControllerApi extends BaseAPI {
    /**
     * delete-userwallet
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public deleteItemResourceUserwalletDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).deleteItemResourceUserwalletDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-userwallet
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public getCollectionResourceUserwalletGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).getCollectionResourceUserwalletGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-userwallet
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public getItemResourceUserwalletGet(id: string, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).getItemResourceUserwalletGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-userwallet
     * @param {string} id 
     * @param {UserWalletRequestBody} userWalletRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public patchItemResourceUserwalletPatch(id: string, userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).patchItemResourceUserwalletPatch(id, userWalletRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-userwallet
     * @param {UserWalletRequestBody} userWalletRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public postCollectionResourceUserwalletPost(userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).postCollectionResourceUserwalletPost(userWalletRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-userwallet
     * @param {string} id 
     * @param {UserWalletRequestBody} userWalletRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public putItemResourceUserwalletPut(id: string, userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).putItemResourceUserwalletPut(id, userWalletRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserWalletSearchControllerApi - axios parameter creator
 * @export
 */
export const UserWalletSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserwalletGet: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userWallets/search/getUserWalletById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserWalletSearchControllerApi - functional programming interface
 * @export
 */
export const UserWalletSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserWalletSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserwalletGet(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserwalletGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletSearchControllerApi.executeSearchUserwalletGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserWalletSearchControllerApi - factory interface
 * @export
 */
export const UserWalletSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserWalletSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserwalletGet(id?: number, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.executeSearchUserwalletGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserWalletSearchControllerApi - object-oriented interface
 * @export
 * @class UserWalletSearchControllerApi
 * @extends {BaseAPI}
 */
export class UserWalletSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletSearchControllerApi
     */
    public executeSearchUserwalletGet(id?: number, options?: RawAxiosRequestConfig) {
        return UserWalletSearchControllerApiFp(this.configuration).executeSearchUserwalletGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



