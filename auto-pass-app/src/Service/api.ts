/* tslint:disable */
/* eslint-disable */
/**
 * OpenApi specification - AutoPass
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Contact: raphaelpaquin19@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AbstractJsonSchemaPropertyObject
 */
export interface AbstractJsonSchemaPropertyObject {
    /**
     * 
     * @type {string}
     * @memberof AbstractJsonSchemaPropertyObject
     */
    'title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AbstractJsonSchemaPropertyObject
     */
    'readOnly'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationResponse
     */
    'user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'user_email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthenticationResponse
     */
    'user_authorities'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'token_type'?: string;
}
/**
 * 
 * @export
 * @interface BasicUserInfoDTO
 */
export interface BasicUserInfoDTO {
    /**
     * 
     * @type {number}
     * @memberof BasicUserInfoDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BasicUserInfoDTO
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicUserInfoDTO
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicUserInfoDTO
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface ChangePasswordDTO
 */
export interface ChangePasswordDTO {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDTO
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CollectionModelEntityModelInvoice
 */
export interface CollectionModelEntityModelInvoice {
    /**
     * 
     * @type {PagedModelEntityModelInvoiceEmbedded}
     * @memberof CollectionModelEntityModelInvoice
     */
    '_embedded'?: PagedModelEntityModelInvoiceEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof CollectionModelEntityModelInvoice
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface CollectionModelEntityModelMembership
 */
export interface CollectionModelEntityModelMembership {
    /**
     * 
     * @type {PagedModelEntityModelMembershipEmbedded}
     * @memberof CollectionModelEntityModelMembership
     */
    '_embedded'?: PagedModelEntityModelMembershipEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof CollectionModelEntityModelMembership
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface CollectionModelEntityModelTicket
 */
export interface CollectionModelEntityModelTicket {
    /**
     * 
     * @type {PagedModelEntityModelTicketEmbedded}
     * @memberof CollectionModelEntityModelTicket
     */
    '_embedded'?: PagedModelEntityModelTicketEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof CollectionModelEntityModelTicket
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface CollectionModelEntityModelUser
 */
export interface CollectionModelEntityModelUser {
    /**
     * 
     * @type {PagedModelEntityModelUserEmbedded}
     * @memberof CollectionModelEntityModelUser
     */
    '_embedded'?: PagedModelEntityModelUserEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof CollectionModelEntityModelUser
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface CollectionModelObject
 */
export interface CollectionModelObject {
    /**
     * 
     * @type {CollectionModelObjectEmbedded}
     * @memberof CollectionModelObject
     */
    '_embedded'?: CollectionModelObjectEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof CollectionModelObject
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface CollectionModelObjectEmbedded
 */
export interface CollectionModelObjectEmbedded {
    /**
     * 
     * @type {Array<object>}
     * @memberof CollectionModelObjectEmbedded
     */
    'objects'?: Array<object>;
}
/**
 * 
 * @export
 * @interface EntityModelInvoice
 */
export interface EntityModelInvoice {
    /**
     * 
     * @type {number}
     * @memberof EntityModelInvoice
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityModelInvoice
     */
    'stripePriceId'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityModelInvoice
     */
    'date'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityModelInvoice
     */
    'stripeCheckoutId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelInvoice
     */
    'productName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelInvoice
     */
    'processed'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelInvoice
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelMembership
 */
export interface EntityModelMembership {
    /**
     * 
     * @type {number}
     * @memberof EntityModelMembership
     */
    'membershipDurationDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntityModelMembership
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityModelMembership
     */
    'stripePriceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelMembership
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelMembership
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelPass
 */
export interface EntityModelPass {
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityModelPass
     */
    'pass'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelPass
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelTicket
 */
export interface EntityModelTicket {
    /**
     * 
     * @type {number}
     * @memberof EntityModelTicket
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntityModelTicket
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityModelTicket
     */
    'stripePriceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelTicket
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelTicket
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelToken
 */
export interface EntityModelToken {
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelToken
     */
    'revoked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityModelToken
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelToken
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelToken
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelUser
 */
export interface EntityModelUser {
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'role'?: EntityModelUserRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'googleAccessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'profileImageUrl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'isProfileImageChanged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'isGoogleWalletPassAdded'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'accountNonExpired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'accountNonLocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'username'?: string;
    /**
     * 
     * @type {Array<GrantedAuthority>}
     * @memberof EntityModelUser
     */
    'authorities'?: Array<GrantedAuthority>;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'credentialsNonExpired'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelUser
     */
    '_links'?: { [key: string]: Link; };
}

export const EntityModelUserRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER',
    GoogleUser: 'GOOGLE_USER',
    ScannerUser: 'SCANNER_USER'
} as const;

export type EntityModelUserRoleEnum = typeof EntityModelUserRoleEnum[keyof typeof EntityModelUserRoleEnum];

/**
 * 
 * @export
 * @interface EntityModelUserWallet
 */
export interface EntityModelUserWallet {
    /**
     * 
     * @type {number}
     * @memberof EntityModelUserWallet
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntityModelUserWallet
     */
    'memberShipEnds'?: number;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelUserWallet
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'path'?: string;
    /**
     * 
     * @type {Array<ErrorResponseStackTraceElementsInner>}
     * @memberof ErrorResponse
     */
    'stackTraceElements'?: Array<ErrorResponseStackTraceElementsInner>;
}
/**
 * 
 * @export
 * @interface ErrorResponseStackTraceElementsInner
 */
export interface ErrorResponseStackTraceElementsInner {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'classLoaderName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'moduleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'moduleVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'methodName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'fileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'lineNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'className'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'nativeMethod'?: boolean;
}
/**
 * 
 * @export
 * @interface GetClientStripeSecretDTO
 */
export interface GetClientStripeSecretDTO {
    /**
     * 
     * @type {string}
     * @memberof GetClientStripeSecretDTO
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetClientStripeSecretDTO
     */
    'priceId'?: string;
}
/**
 * 
 * @export
 * @interface GoogleWalletPassURLViewModel
 */
export interface GoogleWalletPassURLViewModel {
    /**
     * 
     * @type {string}
     * @memberof GoogleWalletPassURLViewModel
     */
    'passUrl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GoogleWalletPassURLViewModel
     */
    'isExpired'?: boolean;
}
/**
 * 
 * @export
 * @interface GrantedAuthority
 */
export interface GrantedAuthority {
    /**
     * 
     * @type {string}
     * @memberof GrantedAuthority
     */
    'authority'?: string;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'stripePriceId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'date'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'stripeCheckoutId'?: string;
    /**
     * 
     * @type {User}
     * @memberof Invoice
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'productName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Invoice
     */
    'processed'?: boolean;
}
/**
 * 
 * @export
 * @interface InvoiceRequestBody
 */
export interface InvoiceRequestBody {
    /**
     * 
     * @type {number}
     * @memberof InvoiceRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceRequestBody
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceRequestBody
     */
    'stripePriceId'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceRequestBody
     */
    'date'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceRequestBody
     */
    'stripeCheckoutId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceRequestBody
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceRequestBody
     */
    'productName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceRequestBody
     */
    'processed'?: boolean;
}
/**
 * 
 * @export
 * @interface IsLoggedInDTO
 */
export interface IsLoggedInDTO {
    /**
     * 
     * @type {string}
     * @memberof IsLoggedInDTO
     */
    'accessToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof IsLoggedInDTO
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: AbstractJsonSchemaPropertyObject; }}
     * @memberof Item
     */
    'properties'?: { [key: string]: AbstractJsonSchemaPropertyObject; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Item
     */
    'requiredProperties'?: Array<string>;
}
/**
 * 
 * @export
 * @interface JsonSchema
 */
export interface JsonSchema {
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: AbstractJsonSchemaPropertyObject; }}
     * @memberof JsonSchema
     */
    'properties'?: { [key: string]: AbstractJsonSchemaPropertyObject; };
    /**
     * 
     * @type {Array<string>}
     * @memberof JsonSchema
     */
    'requiredProperties'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: Item; }}
     * @memberof JsonSchema
     */
    'definitions'?: { [key: string]: Item; };
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    '$schema'?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'hreflang'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'deprecation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Link
     */
    'templated'?: boolean;
}
/**
 * 
 * @export
 * @interface Membership
 */
export interface Membership {
    /**
     * 
     * @type {number}
     * @memberof Membership
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Membership
     */
    'membershipDurationDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof Membership
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof Membership
     */
    'stripePriceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Membership
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface MembershipRequestBody
 */
export interface MembershipRequestBody {
    /**
     * 
     * @type {number}
     * @memberof MembershipRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof MembershipRequestBody
     */
    'membershipDurationDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof MembershipRequestBody
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof MembershipRequestBody
     */
    'stripePriceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MembershipRequestBody
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface PageMetadata
 */
export interface PageMetadata {
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelInvoice
 */
export interface PagedModelEntityModelInvoice {
    /**
     * 
     * @type {PagedModelEntityModelInvoiceEmbedded}
     * @memberof PagedModelEntityModelInvoice
     */
    '_embedded'?: PagedModelEntityModelInvoiceEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelInvoice
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelInvoice
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelInvoiceEmbedded
 */
export interface PagedModelEntityModelInvoiceEmbedded {
    /**
     * 
     * @type {Array<EntityModelInvoice>}
     * @memberof PagedModelEntityModelInvoiceEmbedded
     */
    'invoices'?: Array<EntityModelInvoice>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelMembership
 */
export interface PagedModelEntityModelMembership {
    /**
     * 
     * @type {PagedModelEntityModelMembershipEmbedded}
     * @memberof PagedModelEntityModelMembership
     */
    '_embedded'?: PagedModelEntityModelMembershipEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelMembership
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelMembership
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelMembershipEmbedded
 */
export interface PagedModelEntityModelMembershipEmbedded {
    /**
     * 
     * @type {Array<EntityModelMembership>}
     * @memberof PagedModelEntityModelMembershipEmbedded
     */
    'memberships'?: Array<EntityModelMembership>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPass
 */
export interface PagedModelEntityModelPass {
    /**
     * 
     * @type {PagedModelEntityModelPassEmbedded}
     * @memberof PagedModelEntityModelPass
     */
    '_embedded'?: PagedModelEntityModelPassEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelPass
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelPass
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPassEmbedded
 */
export interface PagedModelEntityModelPassEmbedded {
    /**
     * 
     * @type {Array<EntityModelPass>}
     * @memberof PagedModelEntityModelPassEmbedded
     */
    'passes'?: Array<EntityModelPass>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelTicket
 */
export interface PagedModelEntityModelTicket {
    /**
     * 
     * @type {PagedModelEntityModelTicketEmbedded}
     * @memberof PagedModelEntityModelTicket
     */
    '_embedded'?: PagedModelEntityModelTicketEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelTicket
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelTicket
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelTicketEmbedded
 */
export interface PagedModelEntityModelTicketEmbedded {
    /**
     * 
     * @type {Array<EntityModelTicket>}
     * @memberof PagedModelEntityModelTicketEmbedded
     */
    'tickets'?: Array<EntityModelTicket>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelToken
 */
export interface PagedModelEntityModelToken {
    /**
     * 
     * @type {PagedModelEntityModelTokenEmbedded}
     * @memberof PagedModelEntityModelToken
     */
    '_embedded'?: PagedModelEntityModelTokenEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelToken
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelToken
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelTokenEmbedded
 */
export interface PagedModelEntityModelTokenEmbedded {
    /**
     * 
     * @type {Array<EntityModelToken>}
     * @memberof PagedModelEntityModelTokenEmbedded
     */
    'tokens'?: Array<EntityModelToken>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUser
 */
export interface PagedModelEntityModelUser {
    /**
     * 
     * @type {PagedModelEntityModelUserEmbedded}
     * @memberof PagedModelEntityModelUser
     */
    '_embedded'?: PagedModelEntityModelUserEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelUser
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelUser
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUserEmbedded
 */
export interface PagedModelEntityModelUserEmbedded {
    /**
     * 
     * @type {Array<EntityModelUser>}
     * @memberof PagedModelEntityModelUserEmbedded
     */
    'users'?: Array<EntityModelUser>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUserWallet
 */
export interface PagedModelEntityModelUserWallet {
    /**
     * 
     * @type {PagedModelEntityModelUserWalletEmbedded}
     * @memberof PagedModelEntityModelUserWallet
     */
    '_embedded'?: PagedModelEntityModelUserWalletEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelUserWallet
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelUserWallet
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUserWalletEmbedded
 */
export interface PagedModelEntityModelUserWalletEmbedded {
    /**
     * 
     * @type {Array<EntityModelUserWallet>}
     * @memberof PagedModelEntityModelUserWalletEmbedded
     */
    'userWallets'?: Array<EntityModelUserWallet>;
}
/**
 * 
 * @export
 * @interface Pass
 */
export interface Pass {
    /**
     * 
     * @type {number}
     * @memberof Pass
     */
    'id'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pass
     */
    'pass'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PassRequestBody
 */
export interface PassRequestBody {
    /**
     * 
     * @type {number}
     * @memberof PassRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PassRequestBody
     */
    'pass'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PassValidationResponseViewModel
 */
export interface PassValidationResponseViewModel {
    /**
     * 
     * @type {number}
     * @memberof PassValidationResponseViewModel
     */
    'numberOfTickets'?: number;
    /**
     * 
     * @type {number}
     * @memberof PassValidationResponseViewModel
     */
    'expiresAt'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PassValidationResponseViewModel
     */
    'isValid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PassValidationResponseViewModel
     */
    'responseMessage'?: string;
}
/**
 * Products page view model.
 * @export
 * @interface ProductsViewModel
 */
export interface ProductsViewModel {
    /**
     * List of the tickets
     * @type {Array<Ticket>}
     * @memberof ProductsViewModel
     */
    'ticketsList'?: Array<Ticket>;
    /**
     * List of the memberships
     * @type {Array<Membership>}
     * @memberof ProductsViewModel
     */
    'membershipList'?: Array<Membership>;
}
/**
 * 
 * @export
 * @interface RefreshTokenDTO
 */
export interface RefreshTokenDTO {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenDTO
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface RepresentationModelObject
 */
export interface RepresentationModelObject {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof RepresentationModelObject
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ScannerRegistrationDTO
 */
export interface ScannerRegistrationDTO {
    /**
     * 
     * @type {string}
     * @memberof ScannerRegistrationDTO
     */
    'pwd'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScannerRegistrationDTO
     */
    'busNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScannerRegistrationDTO
     */
    'routeName'?: string;
}
/**
 * 
 * @export
 * @interface SetUserImageRequest
 */
export interface SetUserImageRequest {
    /**
     * 
     * @type {File}
     * @memberof SetUserImageRequest
     */
    'file': File;
}
/**
 * 
 * @export
 * @interface SignInDTO
 */
export interface SignInDTO {
    /**
     * 
     * @type {string}
     * @memberof SignInDTO
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignInDTO
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface SignUpDTO
 */
export interface SignUpDTO {
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'role'?: SignUpDTORoleEnum;
}

export const SignUpDTORoleEnum = {
    Admin: 'ADMIN',
    User: 'USER',
    GoogleUser: 'GOOGLE_USER',
    ScannerUser: 'SCANNER_USER'
} as const;

export type SignUpDTORoleEnum = typeof SignUpDTORoleEnum[keyof typeof SignUpDTORoleEnum];

/**
 * 
 * @export
 * @interface StripeSessionStatusViewModel
 */
export interface StripeSessionStatusViewModel {
    /**
     * 
     * @type {string}
     * @memberof StripeSessionStatusViewModel
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof StripeSessionStatusViewModel
     */
    'customerEmail'?: string;
}
/**
 * List of the tickets
 * @export
 * @interface Ticket
 */
export interface Ticket {
    /**
     * 
     * @type {number}
     * @memberof Ticket
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ticket
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ticket
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'stripePriceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Ticket
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface TicketRequestBody
 */
export interface TicketRequestBody {
    /**
     * 
     * @type {number}
     * @memberof TicketRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof TicketRequestBody
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof TicketRequestBody
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof TicketRequestBody
     */
    'stripePriceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TicketRequestBody
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenRequestBody
 */
export interface TokenRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof TokenRequestBody
     */
    'revoked'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TokenRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TokenRequestBody
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequestBody
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequestBody
     */
    'expiryDate'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserDTO
 */
export interface UpdateUserDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDTO
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDTO
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDTO
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDTO
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {UserWallet}
     * @memberof User
     */
    'wallet'?: UserWallet;
    /**
     * 
     * @type {Pass}
     * @memberof User
     */
    'pass'?: Pass;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role'?: UserRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'googleAccessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profileImageUrl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isProfileImageChanged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isGoogleWalletPassAdded'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'accountNonExpired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'accountNonLocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {Array<GrantedAuthority>}
     * @memberof User
     */
    'authorities'?: Array<GrantedAuthority>;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'credentialsNonExpired'?: boolean;
}

export const UserRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER',
    GoogleUser: 'GOOGLE_USER',
    ScannerUser: 'SCANNER_USER'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * 
 * @export
 * @interface UserRequestBody
 */
export interface UserRequestBody {
    /**
     * 
     * @type {number}
     * @memberof UserRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'wallet'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'pass'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'role'?: UserRequestBodyRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'googleAccessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'profileImageUrl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'isProfileImageChanged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'isGoogleWalletPassAdded'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'accountNonExpired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'accountNonLocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'username'?: string;
    /**
     * 
     * @type {Array<GrantedAuthority>}
     * @memberof UserRequestBody
     */
    'authorities'?: Array<GrantedAuthority>;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'credentialsNonExpired'?: boolean;
}

export const UserRequestBodyRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER',
    GoogleUser: 'GOOGLE_USER',
    ScannerUser: 'SCANNER_USER'
} as const;

export type UserRequestBodyRoleEnum = typeof UserRequestBodyRoleEnum[keyof typeof UserRequestBodyRoleEnum];

/**
 * 
 * @export
 * @interface UserWallet
 */
export interface UserWallet {
    /**
     * 
     * @type {number}
     * @memberof UserWallet
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWallet
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWallet
     */
    'memberShipEnds'?: number;
    /**
     * 
     * @type {Membership}
     * @memberof UserWallet
     */
    'membershipType'?: Membership;
}
/**
 * 
 * @export
 * @interface UserWalletRequestBody
 */
export interface UserWalletRequestBody {
    /**
     * 
     * @type {number}
     * @memberof UserWalletRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWalletRequestBody
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWalletRequestBody
     */
    'memberShipEnds'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserWalletRequestBody
     */
    'membershipType'?: string;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Logs a user in by an email and password. Returns a JWT token for session handling.
         * @param {SignInDTO} signInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (signInDTO: SignInDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInDTO' is not null or undefined
            assertParamExists('authenticate', 'signInDTO', signInDTO)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Changes a user\'s password.
         * @param {ChangePasswordDTO} changePasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordDTO: ChangePasswordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordDTO' is not null or undefined
            assertParamExists('changePassword', 'changePasswordDTO', changePasswordDTO)
            const localVarPath = `/auth/update-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends an email with link to reset password.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('forgotPassword', 'email', email)
            const localVarPath = `/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the backend\'s Ip, which is set in application properties.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppIp: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/app-ip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a user\'s role from access token.
         * @param {string} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRole: async (accessToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessToken' is not null or undefined
            assertParamExists('getUserRole', 'accessToken', accessToken)
            const localVarPath = `/auth/get-user-role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accessToken !== undefined) {
                localVarQueryParameter['accessToken'] = accessToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if the access token is valid.
         * @param {IsLoggedInDTO} isLoggedInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isLogged: async (isLoggedInDTO: IsLoggedInDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isLoggedInDTO' is not null or undefined
            assertParamExists('isLogged', 'isLoggedInDTO', isLoggedInDTO)
            const localVarPath = `/auth/isLogged`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(isLoggedInDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if the refresh token is valid.
         * @param {RefreshTokenDTO} refreshTokenDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRefreshTokenExpired: async (refreshTokenDTO: RefreshTokenDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenDTO' is not null or undefined
            assertParamExists('isRefreshTokenExpired', 'refreshTokenDTO', refreshTokenDTO)
            const localVarPath = `/auth/check-refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This method handles user logout. It removes the refresh token associated with the user (if it exists).
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('logout', 'userId', userId)
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to refresh expired access token. Verifies if refresh token is valid.
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken: async (refreshToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('refreshAccessToken', 'refreshToken', refreshToken)
            const localVarPath = `/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refreshToken !== undefined) {
                localVarQueryParameter['refreshToken'] = refreshToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upon successful registration, it returns JWT and refresh token cookies, similar to the login process. This allows the user to immediately log in after signing up.
         * @param {SignUpDTO} signUpDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (signUpDTO: SignUpDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpDTO' is not null or undefined
            assertParamExists('register', 'signUpDTO', signUpDTO)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Logs a user in by an email and password. Returns a JWT token for session handling.
         * @param {SignInDTO} signInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(signInDTO: SignInDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(signInDTO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Changes a user\'s password.
         * @param {ChangePasswordDTO} changePasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordDTO: ChangePasswordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordDTO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.changePassword']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Sends an email with link to reset password.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(email, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.forgotPassword']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Gets the backend\'s Ip, which is set in application properties.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppIp(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppIp(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.getAppIp']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a user\'s role from access token.
         * @param {string} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRole(accessToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRole(accessToken, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.getUserRole']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Checks if the access token is valid.
         * @param {IsLoggedInDTO} isLoggedInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isLogged(isLoggedInDTO: IsLoggedInDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isLogged(isLoggedInDTO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.isLogged']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Checks if the refresh token is valid.
         * @param {RefreshTokenDTO} refreshTokenDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isRefreshTokenExpired(refreshTokenDTO: RefreshTokenDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isRefreshTokenExpired(refreshTokenDTO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.isRefreshTokenExpired']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary This method handles user logout. It removes the refresh token associated with the user (if it exists).
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.logout']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Used to refresh expired access token. Verifies if refresh token is valid.
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAccessToken(refreshToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(refreshToken, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.refreshAccessToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Upon successful registration, it returns JWT and refresh token cookies, similar to the login process. This allows the user to immediately log in after signing up.
         * @param {SignUpDTO} signUpDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(signUpDTO: SignUpDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(signUpDTO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.register']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Logs a user in by an email and password. Returns a JWT token for session handling.
         * @param {SignInDTO} signInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(signInDTO: SignInDTO, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.authenticate(signInDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Changes a user\'s password.
         * @param {ChangePasswordDTO} changePasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordDTO: ChangePasswordDTO, options?: any): AxiosPromise<boolean> {
            return localVarFp.changePassword(changePasswordDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sends an email with link to reset password.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(email: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.forgotPassword(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the backend\'s Ip, which is set in application properties.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppIp(options?: any): AxiosPromise<string> {
            return localVarFp.getAppIp(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a user\'s role from access token.
         * @param {string} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRole(accessToken: string, options?: any): AxiosPromise<string> {
            return localVarFp.getUserRole(accessToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Checks if the access token is valid.
         * @param {IsLoggedInDTO} isLoggedInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isLogged(isLoggedInDTO: IsLoggedInDTO, options?: any): AxiosPromise<boolean> {
            return localVarFp.isLogged(isLoggedInDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Checks if the refresh token is valid.
         * @param {RefreshTokenDTO} refreshTokenDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRefreshTokenExpired(refreshTokenDTO: RefreshTokenDTO, options?: any): AxiosPromise<boolean> {
            return localVarFp.isRefreshTokenExpired(refreshTokenDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This method handles user logout. It removes the refresh token associated with the user (if it exists).
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.logout(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to refresh expired access token. Verifies if refresh token is valid.
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(refreshToken: string, options?: any): AxiosPromise<string> {
            return localVarFp.refreshAccessToken(refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upon successful registration, it returns JWT and refresh token cookies, similar to the login process. This allows the user to immediately log in after signing up.
         * @param {SignUpDTO} signUpDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(signUpDTO: SignUpDTO, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.register(signUpDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Logs a user in by an email and password. Returns a JWT token for session handling.
     * @param {SignInDTO} signInDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticate(signInDTO: SignInDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticate(signInDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Changes a user\'s password.
     * @param {ChangePasswordDTO} changePasswordDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public changePassword(changePasswordDTO: ChangePasswordDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).changePassword(changePasswordDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sends an email with link to reset password.
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public forgotPassword(email: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).forgotPassword(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the backend\'s Ip, which is set in application properties.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getAppIp(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getAppIp(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a user\'s role from access token.
     * @param {string} accessToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getUserRole(accessToken: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getUserRole(accessToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Checks if the access token is valid.
     * @param {IsLoggedInDTO} isLoggedInDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public isLogged(isLoggedInDTO: IsLoggedInDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).isLogged(isLoggedInDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Checks if the refresh token is valid.
     * @param {RefreshTokenDTO} refreshTokenDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public isRefreshTokenExpired(refreshTokenDTO: RefreshTokenDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).isRefreshTokenExpired(refreshTokenDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This method handles user logout. It removes the refresh token associated with the user (if it exists).
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(userId: number, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to refresh expired access token. Verifies if refresh token is valid.
     * @param {string} refreshToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public refreshAccessToken(refreshToken: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refreshAccessToken(refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upon successful registration, it returns JWT and refresh token cookies, similar to the login process. This allows the user to immediately log in after signing up.
     * @param {SignUpDTO} signUpDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public register(signUpDTO: SignUpDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).register(signUpDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoogleWalletControllerApi - axios parameter creator
 * @export
 */
export const GoogleWalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sets a user\'s pass to active state.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePass: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('activatePass', 'email', email)
            const localVarPath = `/google-wallet-api/activate-pass`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a user\'s pass to expired state.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expirePass: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('expirePass', 'email', email)
            const localVarPath = `/google-wallet-api/expire-pass`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Constructs a URL used to add a pass to a user\'s Google wallet.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavePassURL: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getSavePassURL', 'userId', userId)
            const localVarPath = `/google-wallet-api/get-add-pass-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleWalletControllerApi - functional programming interface
 * @export
 */
export const GoogleWalletControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoogleWalletControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Sets a user\'s pass to active state.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activatePass(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activatePass(email, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GoogleWalletControllerApi.activatePass']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Sets a user\'s pass to expired state.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expirePass(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expirePass(email, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GoogleWalletControllerApi.expirePass']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Constructs a URL used to add a pass to a user\'s Google wallet.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavePassURL(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleWalletPassURLViewModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavePassURL(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GoogleWalletControllerApi.getSavePassURL']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * GoogleWalletControllerApi - factory interface
 * @export
 */
export const GoogleWalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoogleWalletControllerApiFp(configuration)
    return {
        /**
         * Sets a user\'s pass to active state.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePass(email: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.activatePass(email, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a user\'s pass to expired state.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expirePass(email: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.expirePass(email, options).then((request) => request(axios, basePath));
        },
        /**
         * Constructs a URL used to add a pass to a user\'s Google wallet.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavePassURL(userId: number, options?: any): AxiosPromise<GoogleWalletPassURLViewModel> {
            return localVarFp.getSavePassURL(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoogleWalletControllerApi - object-oriented interface
 * @export
 * @class GoogleWalletControllerApi
 * @extends {BaseAPI}
 */
export class GoogleWalletControllerApi extends BaseAPI {
    /**
     * Sets a user\'s pass to active state.
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleWalletControllerApi
     */
    public activatePass(email: string, options?: RawAxiosRequestConfig) {
        return GoogleWalletControllerApiFp(this.configuration).activatePass(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets a user\'s pass to expired state.
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleWalletControllerApi
     */
    public expirePass(email: string, options?: RawAxiosRequestConfig) {
        return GoogleWalletControllerApiFp(this.configuration).expirePass(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Constructs a URL used to add a pass to a user\'s Google wallet.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleWalletControllerApi
     */
    public getSavePassURL(userId: number, options?: RawAxiosRequestConfig) {
        return GoogleWalletControllerApiFp(this.configuration).getSavePassURL(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvoiceControllerApi - axios parameter creator
 * @export
 */
export const InvoiceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets all the scanner accounts found in the database that are not deleted.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoicesByUserId: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllInvoicesByUserId', 'userId', userId)
            const localVarPath = `/v1/api/invoice/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceControllerApi - functional programming interface
 * @export
 */
export const InvoiceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoiceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets all the scanner accounts found in the database that are not deleted.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllInvoicesByUserId(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllInvoicesByUserId(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoiceControllerApi.getAllInvoicesByUserId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * InvoiceControllerApi - factory interface
 * @export
 */
export const InvoiceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoiceControllerApiFp(configuration)
    return {
        /**
         * Gets all the scanner accounts found in the database that are not deleted.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoicesByUserId(userId: number, options?: any): AxiosPromise<Array<Invoice>> {
            return localVarFp.getAllInvoicesByUserId(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceControllerApi - object-oriented interface
 * @export
 * @class InvoiceControllerApi
 * @extends {BaseAPI}
 */
export class InvoiceControllerApi extends BaseAPI {
    /**
     * Gets all the scanner accounts found in the database that are not deleted.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceControllerApi
     */
    public getAllInvoicesByUserId(userId: number, options?: RawAxiosRequestConfig) {
        return InvoiceControllerApiFp(this.configuration).getAllInvoicesByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvoiceEntityControllerApi - axios parameter creator
 * @export
 */
export const InvoiceEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-invoice
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceInvoiceDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceInvoiceDelete', 'id', id)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-invoice
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceInvoiceGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-invoice
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceInvoiceGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceInvoiceGet', 'id', id)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-invoice
         * @param {string} id 
         * @param {InvoiceRequestBody} invoiceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceInvoicePatch: async (id: string, invoiceRequestBody: InvoiceRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceInvoicePatch', 'id', id)
            // verify required parameter 'invoiceRequestBody' is not null or undefined
            assertParamExists('patchItemResourceInvoicePatch', 'invoiceRequestBody', invoiceRequestBody)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-invoice
         * @param {InvoiceRequestBody} invoiceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceInvoicePost: async (invoiceRequestBody: InvoiceRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceInvoicePost', 'invoiceRequestBody', invoiceRequestBody)
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-invoice
         * @param {string} id 
         * @param {InvoiceRequestBody} invoiceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceInvoicePut: async (id: string, invoiceRequestBody: InvoiceRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceInvoicePut', 'id', id)
            // verify required parameter 'invoiceRequestBody' is not null or undefined
            assertParamExists('putItemResourceInvoicePut', 'invoiceRequestBody', invoiceRequestBody)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceEntityControllerApi - functional programming interface
 * @export
 */
export const InvoiceEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoiceEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-invoice
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceInvoiceDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceInvoiceDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoiceEntityControllerApi.deleteItemResourceInvoiceDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-invoice
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceInvoiceGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceInvoiceGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoiceEntityControllerApi.getCollectionResourceInvoiceGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-invoice
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceInvoiceGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceInvoiceGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoiceEntityControllerApi.getItemResourceInvoiceGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-invoice
         * @param {string} id 
         * @param {InvoiceRequestBody} invoiceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceInvoicePatch(id: string, invoiceRequestBody: InvoiceRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceInvoicePatch(id, invoiceRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoiceEntityControllerApi.patchItemResourceInvoicePatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-invoice
         * @param {InvoiceRequestBody} invoiceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceInvoicePost(invoiceRequestBody: InvoiceRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceInvoicePost(invoiceRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoiceEntityControllerApi.postCollectionResourceInvoicePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-invoice
         * @param {string} id 
         * @param {InvoiceRequestBody} invoiceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceInvoicePut(id: string, invoiceRequestBody: InvoiceRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceInvoicePut(id, invoiceRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoiceEntityControllerApi.putItemResourceInvoicePut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * InvoiceEntityControllerApi - factory interface
 * @export
 */
export const InvoiceEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoiceEntityControllerApiFp(configuration)
    return {
        /**
         * delete-invoice
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceInvoiceDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceInvoiceDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-invoice
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceInvoiceGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelInvoice> {
            return localVarFp.getCollectionResourceInvoiceGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-invoice
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceInvoiceGet(id: string, options?: any): AxiosPromise<EntityModelInvoice> {
            return localVarFp.getItemResourceInvoiceGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-invoice
         * @param {string} id 
         * @param {InvoiceRequestBody} invoiceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceInvoicePatch(id: string, invoiceRequestBody: InvoiceRequestBody, options?: any): AxiosPromise<EntityModelInvoice> {
            return localVarFp.patchItemResourceInvoicePatch(id, invoiceRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-invoice
         * @param {InvoiceRequestBody} invoiceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceInvoicePost(invoiceRequestBody: InvoiceRequestBody, options?: any): AxiosPromise<EntityModelInvoice> {
            return localVarFp.postCollectionResourceInvoicePost(invoiceRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-invoice
         * @param {string} id 
         * @param {InvoiceRequestBody} invoiceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceInvoicePut(id: string, invoiceRequestBody: InvoiceRequestBody, options?: any): AxiosPromise<EntityModelInvoice> {
            return localVarFp.putItemResourceInvoicePut(id, invoiceRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceEntityControllerApi - object-oriented interface
 * @export
 * @class InvoiceEntityControllerApi
 * @extends {BaseAPI}
 */
export class InvoiceEntityControllerApi extends BaseAPI {
    /**
     * delete-invoice
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceEntityControllerApi
     */
    public deleteItemResourceInvoiceDelete(id: string, options?: RawAxiosRequestConfig) {
        return InvoiceEntityControllerApiFp(this.configuration).deleteItemResourceInvoiceDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-invoice
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceEntityControllerApi
     */
    public getCollectionResourceInvoiceGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return InvoiceEntityControllerApiFp(this.configuration).getCollectionResourceInvoiceGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-invoice
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceEntityControllerApi
     */
    public getItemResourceInvoiceGet(id: string, options?: RawAxiosRequestConfig) {
        return InvoiceEntityControllerApiFp(this.configuration).getItemResourceInvoiceGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-invoice
     * @param {string} id 
     * @param {InvoiceRequestBody} invoiceRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceEntityControllerApi
     */
    public patchItemResourceInvoicePatch(id: string, invoiceRequestBody: InvoiceRequestBody, options?: RawAxiosRequestConfig) {
        return InvoiceEntityControllerApiFp(this.configuration).patchItemResourceInvoicePatch(id, invoiceRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-invoice
     * @param {InvoiceRequestBody} invoiceRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceEntityControllerApi
     */
    public postCollectionResourceInvoicePost(invoiceRequestBody: InvoiceRequestBody, options?: RawAxiosRequestConfig) {
        return InvoiceEntityControllerApiFp(this.configuration).postCollectionResourceInvoicePost(invoiceRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-invoice
     * @param {string} id 
     * @param {InvoiceRequestBody} invoiceRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceEntityControllerApi
     */
    public putItemResourceInvoicePut(id: string, invoiceRequestBody: InvoiceRequestBody, options?: RawAxiosRequestConfig) {
        return InvoiceEntityControllerApiFp(this.configuration).putItemResourceInvoicePut(id, invoiceRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvoicePropertyReferenceControllerApi - axios parameter creator
 * @export
 */
export const InvoicePropertyReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * patch-user-by-invoice-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceInvoicePatch: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceInvoicePatch', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceInvoicePatch', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/invoices/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-user-by-invoice-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceInvoicePut: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceInvoicePut', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceInvoicePut', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/invoices/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-user-by-invoice-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdInvoiceDelete: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdInvoiceDelete', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdInvoiceDelete', 'propertyId', propertyId)
            const localVarPath = `/invoices/{id}/user/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-user-by-invoice-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceInvoiceDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceInvoiceDelete', 'id', id)
            const localVarPath = `/invoices/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user-by-invoice-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceInvoiceGet: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceInvoiceGet', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceInvoiceGet', 'propertyId', propertyId)
            const localVarPath = `/invoices/{id}/user/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user-by-invoice-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceInvoiceGet1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceInvoiceGet1', 'id', id)
            const localVarPath = `/invoices/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicePropertyReferenceControllerApi - functional programming interface
 * @export
 */
export const InvoicePropertyReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicePropertyReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * patch-user-by-invoice-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceInvoicePatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceInvoicePatch(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicePropertyReferenceControllerApi.createPropertyReferenceInvoicePatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-user-by-invoice-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceInvoicePut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceInvoicePut(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicePropertyReferenceControllerApi.createPropertyReferenceInvoicePut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-user-by-invoice-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdInvoiceDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdInvoiceDelete(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicePropertyReferenceControllerApi.deletePropertyReferenceIdInvoiceDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-user-by-invoice-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceInvoiceDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceInvoiceDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicePropertyReferenceControllerApi.deletePropertyReferenceInvoiceDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user-by-invoice-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceInvoiceGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceInvoiceGet(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicePropertyReferenceControllerApi.followPropertyReferenceInvoiceGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user-by-invoice-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceInvoiceGet1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceInvoiceGet1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicePropertyReferenceControllerApi.followPropertyReferenceInvoiceGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * InvoicePropertyReferenceControllerApi - factory interface
 * @export
 */
export const InvoicePropertyReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicePropertyReferenceControllerApiFp(configuration)
    return {
        /**
         * patch-user-by-invoice-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceInvoicePatch(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.createPropertyReferenceInvoicePatch(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-user-by-invoice-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceInvoicePut(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.createPropertyReferenceInvoicePut(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-user-by-invoice-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdInvoiceDelete(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdInvoiceDelete(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-user-by-invoice-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceInvoiceDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceInvoiceDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user-by-invoice-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceInvoiceGet(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.followPropertyReferenceInvoiceGet(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user-by-invoice-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceInvoiceGet1(id: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.followPropertyReferenceInvoiceGet1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicePropertyReferenceControllerApi - object-oriented interface
 * @export
 * @class InvoicePropertyReferenceControllerApi
 * @extends {BaseAPI}
 */
export class InvoicePropertyReferenceControllerApi extends BaseAPI {
    /**
     * patch-user-by-invoice-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePropertyReferenceControllerApi
     */
    public createPropertyReferenceInvoicePatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return InvoicePropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceInvoicePatch(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-user-by-invoice-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePropertyReferenceControllerApi
     */
    public createPropertyReferenceInvoicePut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return InvoicePropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceInvoicePut(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-user-by-invoice-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdInvoiceDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return InvoicePropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdInvoiceDelete(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-user-by-invoice-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePropertyReferenceControllerApi
     */
    public deletePropertyReferenceInvoiceDelete(id: string, options?: RawAxiosRequestConfig) {
        return InvoicePropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceInvoiceDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user-by-invoice-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePropertyReferenceControllerApi
     */
    public followPropertyReferenceInvoiceGet(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return InvoicePropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceInvoiceGet(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user-by-invoice-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePropertyReferenceControllerApi
     */
    public followPropertyReferenceInvoiceGet1(id: string, options?: RawAxiosRequestConfig) {
        return InvoicePropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceInvoiceGet1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvoiceSearchControllerApi - axios parameter creator
 * @export
 */
export const InvoiceSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [stripeCheckoutId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchInvoiceGet: async (stripeCheckoutId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices/search/existsByStripeCheckoutId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (stripeCheckoutId !== undefined) {
                localVarQueryParameter['stripeCheckoutId'] = stripeCheckoutId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchInvoiceGet1: async (userId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices/search/getAllByUserId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [stripeCheckoutId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchInvoiceGet2: async (stripeCheckoutId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices/search/getInvoiceByStripeCheckoutId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (stripeCheckoutId !== undefined) {
                localVarQueryParameter['stripeCheckoutId'] = stripeCheckoutId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceSearchControllerApi - functional programming interface
 * @export
 */
export const InvoiceSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoiceSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [stripeCheckoutId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchInvoiceGet(stripeCheckoutId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchInvoiceGet(stripeCheckoutId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoiceSearchControllerApi.executeSearchInvoiceGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchInvoiceGet1(userId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionModelEntityModelInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchInvoiceGet1(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoiceSearchControllerApi.executeSearchInvoiceGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [stripeCheckoutId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchInvoiceGet2(stripeCheckoutId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchInvoiceGet2(stripeCheckoutId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoiceSearchControllerApi.executeSearchInvoiceGet2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * InvoiceSearchControllerApi - factory interface
 * @export
 */
export const InvoiceSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoiceSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [stripeCheckoutId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchInvoiceGet(stripeCheckoutId?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.executeSearchInvoiceGet(stripeCheckoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchInvoiceGet1(userId?: number, options?: any): AxiosPromise<CollectionModelEntityModelInvoice> {
            return localVarFp.executeSearchInvoiceGet1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [stripeCheckoutId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchInvoiceGet2(stripeCheckoutId?: string, options?: any): AxiosPromise<EntityModelInvoice> {
            return localVarFp.executeSearchInvoiceGet2(stripeCheckoutId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceSearchControllerApi - object-oriented interface
 * @export
 * @class InvoiceSearchControllerApi
 * @extends {BaseAPI}
 */
export class InvoiceSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [stripeCheckoutId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceSearchControllerApi
     */
    public executeSearchInvoiceGet(stripeCheckoutId?: string, options?: RawAxiosRequestConfig) {
        return InvoiceSearchControllerApiFp(this.configuration).executeSearchInvoiceGet(stripeCheckoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceSearchControllerApi
     */
    public executeSearchInvoiceGet1(userId?: number, options?: RawAxiosRequestConfig) {
        return InvoiceSearchControllerApiFp(this.configuration).executeSearchInvoiceGet1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [stripeCheckoutId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceSearchControllerApi
     */
    public executeSearchInvoiceGet2(stripeCheckoutId?: string, options?: RawAxiosRequestConfig) {
        return InvoiceSearchControllerApiFp(this.configuration).executeSearchInvoiceGet2(stripeCheckoutId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembershipEntityControllerApi - axios parameter creator
 * @export
 */
export const MembershipEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceMembershipDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceMembershipDelete', 'id', id)
            const localVarPath = `/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-membership
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceMembershipGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceMembershipGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceMembershipGet', 'id', id)
            const localVarPath = `/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceMembershipPatch: async (id: string, membershipRequestBody: MembershipRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceMembershipPatch', 'id', id)
            // verify required parameter 'membershipRequestBody' is not null or undefined
            assertParamExists('patchItemResourceMembershipPatch', 'membershipRequestBody', membershipRequestBody)
            const localVarPath = `/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membershipRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-membership
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceMembershipPost: async (membershipRequestBody: MembershipRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'membershipRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceMembershipPost', 'membershipRequestBody', membershipRequestBody)
            const localVarPath = `/memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membershipRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceMembershipPut: async (id: string, membershipRequestBody: MembershipRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceMembershipPut', 'id', id)
            // verify required parameter 'membershipRequestBody' is not null or undefined
            assertParamExists('putItemResourceMembershipPut', 'membershipRequestBody', membershipRequestBody)
            const localVarPath = `/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membershipRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembershipEntityControllerApi - functional programming interface
 * @export
 */
export const MembershipEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembershipEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceMembershipDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceMembershipDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.deleteItemResourceMembershipDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-membership
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceMembershipGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceMembershipGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.getCollectionResourceMembershipGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceMembershipGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceMembershipGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.getItemResourceMembershipGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceMembershipPatch(id: string, membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceMembershipPatch(id, membershipRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.patchItemResourceMembershipPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-membership
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceMembershipPost(membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceMembershipPost(membershipRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.postCollectionResourceMembershipPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceMembershipPut(id: string, membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceMembershipPut(id, membershipRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.putItemResourceMembershipPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MembershipEntityControllerApi - factory interface
 * @export
 */
export const MembershipEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembershipEntityControllerApiFp(configuration)
    return {
        /**
         * delete-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceMembershipDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceMembershipDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-membership
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceMembershipGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelMembership> {
            return localVarFp.getCollectionResourceMembershipGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceMembershipGet(id: string, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.getItemResourceMembershipGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceMembershipPatch(id: string, membershipRequestBody: MembershipRequestBody, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.patchItemResourceMembershipPatch(id, membershipRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-membership
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceMembershipPost(membershipRequestBody: MembershipRequestBody, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.postCollectionResourceMembershipPost(membershipRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceMembershipPut(id: string, membershipRequestBody: MembershipRequestBody, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.putItemResourceMembershipPut(id, membershipRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembershipEntityControllerApi - object-oriented interface
 * @export
 * @class MembershipEntityControllerApi
 * @extends {BaseAPI}
 */
export class MembershipEntityControllerApi extends BaseAPI {
    /**
     * delete-membership
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public deleteItemResourceMembershipDelete(id: string, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).deleteItemResourceMembershipDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-membership
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public getCollectionResourceMembershipGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).getCollectionResourceMembershipGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-membership
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public getItemResourceMembershipGet(id: string, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).getItemResourceMembershipGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-membership
     * @param {string} id 
     * @param {MembershipRequestBody} membershipRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public patchItemResourceMembershipPatch(id: string, membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).patchItemResourceMembershipPatch(id, membershipRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-membership
     * @param {MembershipRequestBody} membershipRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public postCollectionResourceMembershipPost(membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).postCollectionResourceMembershipPost(membershipRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-membership
     * @param {string} id 
     * @param {MembershipRequestBody} membershipRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public putItemResourceMembershipPut(id: string, membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).putItemResourceMembershipPut(id, membershipRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembershipSearchControllerApi - axios parameter creator
 * @export
 */
export const MembershipSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchMembershipGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/memberships/search/getAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [priceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchMembershipGet1: async (priceId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/memberships/search/getMembershipByStripePriceId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (priceId !== undefined) {
                localVarQueryParameter['priceId'] = priceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembershipSearchControllerApi - functional programming interface
 * @export
 */
export const MembershipSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembershipSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchMembershipGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionModelEntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchMembershipGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipSearchControllerApi.executeSearchMembershipGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [priceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchMembershipGet1(priceId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchMembershipGet1(priceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipSearchControllerApi.executeSearchMembershipGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MembershipSearchControllerApi - factory interface
 * @export
 */
export const MembershipSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembershipSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchMembershipGet(options?: any): AxiosPromise<CollectionModelEntityModelMembership> {
            return localVarFp.executeSearchMembershipGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [priceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchMembershipGet1(priceId?: string, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.executeSearchMembershipGet1(priceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembershipSearchControllerApi - object-oriented interface
 * @export
 * @class MembershipSearchControllerApi
 * @extends {BaseAPI}
 */
export class MembershipSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipSearchControllerApi
     */
    public executeSearchMembershipGet(options?: RawAxiosRequestConfig) {
        return MembershipSearchControllerApiFp(this.configuration).executeSearchMembershipGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [priceId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipSearchControllerApi
     */
    public executeSearchMembershipGet1(priceId?: string, options?: RawAxiosRequestConfig) {
        return MembershipSearchControllerApiFp(this.configuration).executeSearchMembershipGet1(priceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OAuth2ControllerApi - axios parameter creator
 * @export
 */
export const OAuth2ControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/google/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuth2ControllerApi - functional programming interface
 * @export
 */
export const OAuth2ControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuth2ControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser1(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OAuth2ControllerApi.getUser1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OAuth2ControllerApi - factory interface
 * @export
 */
export const OAuth2ControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuth2ControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser1(options?: any): AxiosPromise<User> {
            return localVarFp.getUser1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuth2ControllerApi - object-oriented interface
 * @export
 * @class OAuth2ControllerApi
 * @extends {BaseAPI}
 */
export class OAuth2ControllerApi extends BaseAPI {
    /**
     * 
     * @summary Gets a user\'s information by their ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ControllerApi
     */
    public getUser1(options?: RawAxiosRequestConfig) {
        return OAuth2ControllerApiFp(this.configuration).getUser1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PassEntityControllerApi - axios parameter creator
 * @export
 */
export const PassEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourcePassDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourcePassDelete', 'id', id)
            const localVarPath = `/passes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-pass
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourcePassGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/passes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourcePassGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourcePassGet', 'id', id)
            const localVarPath = `/passes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourcePassPatch: async (id: string, passRequestBody: PassRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourcePassPatch', 'id', id)
            // verify required parameter 'passRequestBody' is not null or undefined
            assertParamExists('patchItemResourcePassPatch', 'passRequestBody', passRequestBody)
            const localVarPath = `/passes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-pass
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourcePassPost: async (passRequestBody: PassRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passRequestBody' is not null or undefined
            assertParamExists('postCollectionResourcePassPost', 'passRequestBody', passRequestBody)
            const localVarPath = `/passes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourcePassPut: async (id: string, passRequestBody: PassRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourcePassPut', 'id', id)
            // verify required parameter 'passRequestBody' is not null or undefined
            assertParamExists('putItemResourcePassPut', 'passRequestBody', passRequestBody)
            const localVarPath = `/passes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PassEntityControllerApi - functional programming interface
 * @export
 */
export const PassEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PassEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourcePassDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourcePassDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.deleteItemResourcePassDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-pass
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourcePassGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourcePassGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.getCollectionResourcePassGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourcePassGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourcePassGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.getItemResourcePassGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourcePassPatch(id: string, passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourcePassPatch(id, passRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.patchItemResourcePassPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-pass
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourcePassPost(passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourcePassPost(passRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.postCollectionResourcePassPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourcePassPut(id: string, passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourcePassPut(id, passRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.putItemResourcePassPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PassEntityControllerApi - factory interface
 * @export
 */
export const PassEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PassEntityControllerApiFp(configuration)
    return {
        /**
         * delete-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourcePassDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourcePassDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-pass
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourcePassGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelPass> {
            return localVarFp.getCollectionResourcePassGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourcePassGet(id: string, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.getItemResourcePassGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourcePassPatch(id: string, passRequestBody: PassRequestBody, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.patchItemResourcePassPatch(id, passRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-pass
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourcePassPost(passRequestBody: PassRequestBody, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.postCollectionResourcePassPost(passRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourcePassPut(id: string, passRequestBody: PassRequestBody, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.putItemResourcePassPut(id, passRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PassEntityControllerApi - object-oriented interface
 * @export
 * @class PassEntityControllerApi
 * @extends {BaseAPI}
 */
export class PassEntityControllerApi extends BaseAPI {
    /**
     * delete-pass
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public deleteItemResourcePassDelete(id: string, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).deleteItemResourcePassDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-pass
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public getCollectionResourcePassGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).getCollectionResourcePassGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-pass
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public getItemResourcePassGet(id: string, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).getItemResourcePassGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-pass
     * @param {string} id 
     * @param {PassRequestBody} passRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public patchItemResourcePassPatch(id: string, passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).patchItemResourcePassPatch(id, passRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-pass
     * @param {PassRequestBody} passRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public postCollectionResourcePassPost(passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).postCollectionResourcePassPost(passRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-pass
     * @param {string} id 
     * @param {PassRequestBody} passRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public putItemResourcePassPut(id: string, passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).putItemResourcePassPut(id, passRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductsControllerApi - axios parameter creator
 * @export
 */
export const ProductsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets all the products of the application that isn\'t deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/get-all-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsControllerApi - functional programming interface
 * @export
 */
export const ProductsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets all the products of the application that isn\'t deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProducts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsViewModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProducts(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsControllerApi.getAllProducts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProductsControllerApi - factory interface
 * @export
 */
export const ProductsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsControllerApiFp(configuration)
    return {
        /**
         * Gets all the products of the application that isn\'t deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(options?: any): AxiosPromise<ProductsViewModel> {
            return localVarFp.getAllProducts(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsControllerApi - object-oriented interface
 * @export
 * @class ProductsControllerApi
 * @extends {BaseAPI}
 */
export class ProductsControllerApi extends BaseAPI {
    /**
     * Gets all the products of the application that isn\'t deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsControllerApi
     */
    public getAllProducts(options?: RawAxiosRequestConfig) {
        return ProductsControllerApiFp(this.configuration).getAllProducts(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileControllerApi - axios parameter creator
 * @export
 */
export const ProfileControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor111: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor112: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor113: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/passes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor114: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor115: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor116: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/userWallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor117: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFormsOfMetadata1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileControllerApi - functional programming interface
 * @export
 */
export const ProfileControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor111(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor111(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor111']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor112(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor112(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor112']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor113(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor113(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor113']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor114(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor114(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor114']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor115(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor115(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor115']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor116(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor116(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor116']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor117(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor117(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor117']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllFormsOfMetadata1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepresentationModelObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllFormsOfMetadata1(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.listAllFormsOfMetadata1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProfileControllerApi - factory interface
 * @export
 */
export const ProfileControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor111(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor111(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor112(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor112(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor113(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor113(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor114(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor114(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor115(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor115(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor116(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor116(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor117(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor117(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFormsOfMetadata1(options?: any): AxiosPromise<RepresentationModelObject> {
            return localVarFp.listAllFormsOfMetadata1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileControllerApi - object-oriented interface
 * @export
 * @class ProfileControllerApi
 * @extends {BaseAPI}
 */
export class ProfileControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor111(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor111(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor112(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor112(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor113(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor113(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor114(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor114(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor115(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor115(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor116(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor116(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor117(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor117(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public listAllFormsOfMetadata1(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).listAllFormsOfMetadata1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScannerControllerApi - axios parameter creator
 * @export
 */
export const ScannerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a scanner registration object to create a scanner account.
         * @param {ScannerRegistrationDTO} scannerRegistrationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScannerAccount: async (scannerRegistrationDTO: ScannerRegistrationDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scannerRegistrationDTO' is not null or undefined
            assertParamExists('createScannerAccount', 'scannerRegistrationDTO', scannerRegistrationDTO)
            const localVarPath = `/admin/scanner/create-scanner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scannerRegistrationDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deleted a bus.
         * @param {number} busNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScanner: async (busNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'busNumber' is not null or undefined
            assertParamExists('deleteScanner', 'busNumber', busNumber)
            const localVarPath = `/admin/scanner/delete-bus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (busNumber !== undefined) {
                localVarQueryParameter['busNumber'] = busNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all the scanner accounts found in the database that are not deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllScanners: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/scanner/scanners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a scanner account from bus number.
         * @param {number} busNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScannerByBusNumber: async (busNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'busNumber' is not null or undefined
            assertParamExists('getScannerByBusNumber', 'busNumber', busNumber)
            const localVarPath = `/admin/scanner/scanner-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (busNumber !== undefined) {
                localVarQueryParameter['busNumber'] = busNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScannerControllerApi - functional programming interface
 * @export
 */
export const ScannerControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScannerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a scanner registration object to create a scanner account.
         * @param {ScannerRegistrationDTO} scannerRegistrationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScannerAccount(scannerRegistrationDTO: ScannerRegistrationDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScannerAccount(scannerRegistrationDTO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ScannerControllerApi.createScannerAccount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deleted a bus.
         * @param {number} busNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScanner(busNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScanner(busNumber, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ScannerControllerApi.deleteScanner']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets all the scanner accounts found in the database that are not deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllScanners(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllScanners(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ScannerControllerApi.getAllScanners']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets a scanner account from bus number.
         * @param {number} busNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScannerByBusNumber(busNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScannerByBusNumber(busNumber, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ScannerControllerApi.getScannerByBusNumber']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ScannerControllerApi - factory interface
 * @export
 */
export const ScannerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScannerControllerApiFp(configuration)
    return {
        /**
         * Takes a scanner registration object to create a scanner account.
         * @param {ScannerRegistrationDTO} scannerRegistrationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScannerAccount(scannerRegistrationDTO: ScannerRegistrationDTO, options?: any): AxiosPromise<User> {
            return localVarFp.createScannerAccount(scannerRegistrationDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Deleted a bus.
         * @param {number} busNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScanner(busNumber: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteScanner(busNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all the scanner accounts found in the database that are not deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllScanners(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.getAllScanners(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a scanner account from bus number.
         * @param {number} busNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScannerByBusNumber(busNumber: number, options?: any): AxiosPromise<User> {
            return localVarFp.getScannerByBusNumber(busNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScannerControllerApi - object-oriented interface
 * @export
 * @class ScannerControllerApi
 * @extends {BaseAPI}
 */
export class ScannerControllerApi extends BaseAPI {
    /**
     * Takes a scanner registration object to create a scanner account.
     * @param {ScannerRegistrationDTO} scannerRegistrationDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScannerControllerApi
     */
    public createScannerAccount(scannerRegistrationDTO: ScannerRegistrationDTO, options?: RawAxiosRequestConfig) {
        return ScannerControllerApiFp(this.configuration).createScannerAccount(scannerRegistrationDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deleted a bus.
     * @param {number} busNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScannerControllerApi
     */
    public deleteScanner(busNumber: number, options?: RawAxiosRequestConfig) {
        return ScannerControllerApiFp(this.configuration).deleteScanner(busNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all the scanner accounts found in the database that are not deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScannerControllerApi
     */
    public getAllScanners(options?: RawAxiosRequestConfig) {
        return ScannerControllerApiFp(this.configuration).getAllScanners(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a scanner account from bus number.
     * @param {number} busNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScannerControllerApi
     */
    public getScannerByBusNumber(busNumber: number, options?: RawAxiosRequestConfig) {
        return ScannerControllerApiFp(this.configuration).getScannerByBusNumber(busNumber, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StripeControllerApi - axios parameter creator
 * @export
 */
export const StripeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a checkout embedded session options.
         * @param {GetClientStripeSecretDTO} dto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientSecret: async (dto: GetClientStripeSecretDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dto' is not null or undefined
            assertParamExists('getClientSecret', 'dto', dto)
            const localVarPath = `/api/payment/create-checkout-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dto !== undefined) {
                for (const [key, value] of Object.entries(dto)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the sessions payment status.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionStatus: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getSessionStatus', 'sessionId', sessionId)
            const localVarPath = `/api/payment/session-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sessionId !== undefined) {
                localVarQueryParameter['sessionId'] = sessionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeControllerApi - functional programming interface
 * @export
 */
export const StripeControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a checkout embedded session options.
         * @param {GetClientStripeSecretDTO} dto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientSecret(dto: GetClientStripeSecretDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientSecret(dto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StripeControllerApi.getClientSecret']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Gets the sessions payment status.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionStatus(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeSessionStatusViewModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionStatus(sessionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StripeControllerApi.getSessionStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * StripeControllerApi - factory interface
 * @export
 */
export const StripeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a checkout embedded session options.
         * @param {GetClientStripeSecretDTO} dto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientSecret(dto: GetClientStripeSecretDTO, options?: any): AxiosPromise<string> {
            return localVarFp.getClientSecret(dto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the sessions payment status.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionStatus(sessionId: string, options?: any): AxiosPromise<StripeSessionStatusViewModel> {
            return localVarFp.getSessionStatus(sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripeControllerApi - object-oriented interface
 * @export
 * @class StripeControllerApi
 * @extends {BaseAPI}
 */
export class StripeControllerApi extends BaseAPI {
    /**
     * 
     * @summary Creates a checkout embedded session options.
     * @param {GetClientStripeSecretDTO} dto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeControllerApi
     */
    public getClientSecret(dto: GetClientStripeSecretDTO, options?: RawAxiosRequestConfig) {
        return StripeControllerApiFp(this.configuration).getClientSecret(dto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the sessions payment status.
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeControllerApi
     */
    public getSessionStatus(sessionId: string, options?: RawAxiosRequestConfig) {
        return StripeControllerApiFp(this.configuration).getSessionStatus(sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TerminalControllerApi - axios parameter creator
 * @export
 */
export const TerminalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Validates a google wallet QR-Code.
         * @param {string} barcodeValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePass: async (barcodeValue: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcodeValue' is not null or undefined
            assertParamExists('validatePass', 'barcodeValue', barcodeValue)
            const localVarPath = `/terminal/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (barcodeValue !== undefined) {
                localVarQueryParameter['barcodeValue'] = barcodeValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerminalControllerApi - functional programming interface
 * @export
 */
export const TerminalControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerminalControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Validates a google wallet QR-Code.
         * @param {string} barcodeValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatePass(barcodeValue: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PassValidationResponseViewModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatePass(barcodeValue, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TerminalControllerApi.validatePass']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TerminalControllerApi - factory interface
 * @export
 */
export const TerminalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerminalControllerApiFp(configuration)
    return {
        /**
         * Validates a google wallet QR-Code.
         * @param {string} barcodeValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePass(barcodeValue: string, options?: any): AxiosPromise<PassValidationResponseViewModel> {
            return localVarFp.validatePass(barcodeValue, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerminalControllerApi - object-oriented interface
 * @export
 * @class TerminalControllerApi
 * @extends {BaseAPI}
 */
export class TerminalControllerApi extends BaseAPI {
    /**
     * Validates a google wallet QR-Code.
     * @param {string} barcodeValue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalControllerApi
     */
    public validatePass(barcodeValue: string, options?: RawAxiosRequestConfig) {
        return TerminalControllerApiFp(this.configuration).validatePass(barcodeValue, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TicketEntityControllerApi - axios parameter creator
 * @export
 */
export const TicketEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceTicketDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceTicketDelete', 'id', id)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-ticket
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceTicketGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceTicketGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceTicketGet', 'id', id)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceTicketPatch: async (id: string, ticketRequestBody: TicketRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceTicketPatch', 'id', id)
            // verify required parameter 'ticketRequestBody' is not null or undefined
            assertParamExists('patchItemResourceTicketPatch', 'ticketRequestBody', ticketRequestBody)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-ticket
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceTicketPost: async (ticketRequestBody: TicketRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceTicketPost', 'ticketRequestBody', ticketRequestBody)
            const localVarPath = `/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceTicketPut: async (id: string, ticketRequestBody: TicketRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceTicketPut', 'id', id)
            // verify required parameter 'ticketRequestBody' is not null or undefined
            assertParamExists('putItemResourceTicketPut', 'ticketRequestBody', ticketRequestBody)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TicketEntityControllerApi - functional programming interface
 * @export
 */
export const TicketEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TicketEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceTicketDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceTicketDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.deleteItemResourceTicketDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-ticket
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceTicketGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceTicketGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.getCollectionResourceTicketGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceTicketGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceTicketGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.getItemResourceTicketGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceTicketPatch(id: string, ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceTicketPatch(id, ticketRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.patchItemResourceTicketPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-ticket
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceTicketPost(ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceTicketPost(ticketRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.postCollectionResourceTicketPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceTicketPut(id: string, ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceTicketPut(id, ticketRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.putItemResourceTicketPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TicketEntityControllerApi - factory interface
 * @export
 */
export const TicketEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TicketEntityControllerApiFp(configuration)
    return {
        /**
         * delete-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceTicketDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceTicketDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-ticket
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceTicketGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelTicket> {
            return localVarFp.getCollectionResourceTicketGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceTicketGet(id: string, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.getItemResourceTicketGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceTicketPatch(id: string, ticketRequestBody: TicketRequestBody, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.patchItemResourceTicketPatch(id, ticketRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-ticket
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceTicketPost(ticketRequestBody: TicketRequestBody, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.postCollectionResourceTicketPost(ticketRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceTicketPut(id: string, ticketRequestBody: TicketRequestBody, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.putItemResourceTicketPut(id, ticketRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TicketEntityControllerApi - object-oriented interface
 * @export
 * @class TicketEntityControllerApi
 * @extends {BaseAPI}
 */
export class TicketEntityControllerApi extends BaseAPI {
    /**
     * delete-ticket
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public deleteItemResourceTicketDelete(id: string, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).deleteItemResourceTicketDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-ticket
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public getCollectionResourceTicketGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).getCollectionResourceTicketGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-ticket
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public getItemResourceTicketGet(id: string, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).getItemResourceTicketGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-ticket
     * @param {string} id 
     * @param {TicketRequestBody} ticketRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public patchItemResourceTicketPatch(id: string, ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).patchItemResourceTicketPatch(id, ticketRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-ticket
     * @param {TicketRequestBody} ticketRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public postCollectionResourceTicketPost(ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).postCollectionResourceTicketPost(ticketRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-ticket
     * @param {string} id 
     * @param {TicketRequestBody} ticketRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public putItemResourceTicketPut(id: string, ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).putItemResourceTicketPut(id, ticketRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TicketSearchControllerApi - axios parameter creator
 * @export
 */
export const TicketSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTicketGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tickets/search/getAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [priceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTicketGet1: async (priceId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tickets/search/getTicketByStripePriceId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (priceId !== undefined) {
                localVarQueryParameter['priceId'] = priceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TicketSearchControllerApi - functional programming interface
 * @export
 */
export const TicketSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TicketSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchTicketGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionModelEntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchTicketGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketSearchControllerApi.executeSearchTicketGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [priceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchTicketGet1(priceId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchTicketGet1(priceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketSearchControllerApi.executeSearchTicketGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TicketSearchControllerApi - factory interface
 * @export
 */
export const TicketSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TicketSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTicketGet(options?: any): AxiosPromise<CollectionModelEntityModelTicket> {
            return localVarFp.executeSearchTicketGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [priceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTicketGet1(priceId?: string, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.executeSearchTicketGet1(priceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TicketSearchControllerApi - object-oriented interface
 * @export
 * @class TicketSearchControllerApi
 * @extends {BaseAPI}
 */
export class TicketSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketSearchControllerApi
     */
    public executeSearchTicketGet(options?: RawAxiosRequestConfig) {
        return TicketSearchControllerApiFp(this.configuration).executeSearchTicketGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [priceId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketSearchControllerApi
     */
    public executeSearchTicketGet1(priceId?: string, options?: RawAxiosRequestConfig) {
        return TicketSearchControllerApiFp(this.configuration).executeSearchTicketGet1(priceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokenEntityControllerApi - axios parameter creator
 * @export
 */
export const TokenEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceTokenDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceTokenDelete', 'id', id)
            const localVarPath = `/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-token
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceTokenGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceTokenGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceTokenGet', 'id', id)
            const localVarPath = `/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceTokenPatch: async (id: string, tokenRequestBody: TokenRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceTokenPatch', 'id', id)
            // verify required parameter 'tokenRequestBody' is not null or undefined
            assertParamExists('patchItemResourceTokenPatch', 'tokenRequestBody', tokenRequestBody)
            const localVarPath = `/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-token
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceTokenPost: async (tokenRequestBody: TokenRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceTokenPost', 'tokenRequestBody', tokenRequestBody)
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceTokenPut: async (id: string, tokenRequestBody: TokenRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceTokenPut', 'id', id)
            // verify required parameter 'tokenRequestBody' is not null or undefined
            assertParamExists('putItemResourceTokenPut', 'tokenRequestBody', tokenRequestBody)
            const localVarPath = `/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenEntityControllerApi - functional programming interface
 * @export
 */
export const TokenEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceTokenDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceTokenDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.deleteItemResourceTokenDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-token
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceTokenGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceTokenGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.getCollectionResourceTokenGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceTokenGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceTokenGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.getItemResourceTokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceTokenPatch(id: string, tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceTokenPatch(id, tokenRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.patchItemResourceTokenPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-token
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceTokenPost(tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceTokenPost(tokenRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.postCollectionResourceTokenPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceTokenPut(id: string, tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceTokenPut(id, tokenRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.putItemResourceTokenPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TokenEntityControllerApi - factory interface
 * @export
 */
export const TokenEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenEntityControllerApiFp(configuration)
    return {
        /**
         * delete-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceTokenDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceTokenDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-token
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceTokenGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelToken> {
            return localVarFp.getCollectionResourceTokenGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceTokenGet(id: string, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.getItemResourceTokenGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceTokenPatch(id: string, tokenRequestBody: TokenRequestBody, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.patchItemResourceTokenPatch(id, tokenRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-token
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceTokenPost(tokenRequestBody: TokenRequestBody, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.postCollectionResourceTokenPost(tokenRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceTokenPut(id: string, tokenRequestBody: TokenRequestBody, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.putItemResourceTokenPut(id, tokenRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenEntityControllerApi - object-oriented interface
 * @export
 * @class TokenEntityControllerApi
 * @extends {BaseAPI}
 */
export class TokenEntityControllerApi extends BaseAPI {
    /**
     * delete-token
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public deleteItemResourceTokenDelete(id: string, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).deleteItemResourceTokenDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-token
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public getCollectionResourceTokenGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).getCollectionResourceTokenGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-token
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public getItemResourceTokenGet(id: string, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).getItemResourceTokenGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-token
     * @param {string} id 
     * @param {TokenRequestBody} tokenRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public patchItemResourceTokenPatch(id: string, tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).patchItemResourceTokenPatch(id, tokenRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-token
     * @param {TokenRequestBody} tokenRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public postCollectionResourceTokenPost(tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).postCollectionResourceTokenPost(tokenRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-token
     * @param {string} id 
     * @param {TokenRequestBody} tokenRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public putItemResourceTokenPut(id: string, tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).putItemResourceTokenPut(id, tokenRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokenPropertyReferenceControllerApi - axios parameter creator
 * @export
 */
export const TokenPropertyReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * patch-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceTokenPatch: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceTokenPatch', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceTokenPatch', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/tokens/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceTokenPut: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceTokenPut', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceTokenPut', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/tokens/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdTokenDelete: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdTokenDelete', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdTokenDelete', 'propertyId', propertyId)
            const localVarPath = `/tokens/{id}/user/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceTokenDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceTokenDelete', 'id', id)
            const localVarPath = `/tokens/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceTokenGet: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceTokenGet', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceTokenGet', 'propertyId', propertyId)
            const localVarPath = `/tokens/{id}/user/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceTokenGet1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceTokenGet1', 'id', id)
            const localVarPath = `/tokens/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenPropertyReferenceControllerApi - functional programming interface
 * @export
 */
export const TokenPropertyReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenPropertyReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * patch-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceTokenPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceTokenPatch(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.createPropertyReferenceTokenPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceTokenPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceTokenPut(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.createPropertyReferenceTokenPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdTokenDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdTokenDelete(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.deletePropertyReferenceIdTokenDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceTokenDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceTokenDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.deletePropertyReferenceTokenDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceTokenGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceTokenGet(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.followPropertyReferenceTokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceTokenGet1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceTokenGet1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.followPropertyReferenceTokenGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TokenPropertyReferenceControllerApi - factory interface
 * @export
 */
export const TokenPropertyReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenPropertyReferenceControllerApiFp(configuration)
    return {
        /**
         * patch-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceTokenPatch(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.createPropertyReferenceTokenPatch(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceTokenPut(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.createPropertyReferenceTokenPut(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdTokenDelete(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdTokenDelete(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceTokenDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceTokenDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceTokenGet(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.followPropertyReferenceTokenGet(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceTokenGet1(id: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.followPropertyReferenceTokenGet1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenPropertyReferenceControllerApi - object-oriented interface
 * @export
 * @class TokenPropertyReferenceControllerApi
 * @extends {BaseAPI}
 */
export class TokenPropertyReferenceControllerApi extends BaseAPI {
    /**
     * patch-user-by-token-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public createPropertyReferenceTokenPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceTokenPatch(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-user-by-token-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public createPropertyReferenceTokenPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceTokenPut(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-user-by-token-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdTokenDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdTokenDelete(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-user-by-token-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public deletePropertyReferenceTokenDelete(id: string, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceTokenDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user-by-token-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public followPropertyReferenceTokenGet(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceTokenGet(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user-by-token-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public followPropertyReferenceTokenGet1(id: string, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceTokenGet1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokenSearchControllerApi - axios parameter creator
 * @export
 */
export const TokenSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTokenGet: async (token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens/search/findByToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTokenGet1: async (user?: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens/search/findByUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (user !== undefined) {
                for (const [key, value] of Object.entries(user)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenSearchControllerApi - functional programming interface
 * @export
 */
export const TokenSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchTokenGet(token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchTokenGet(token, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenSearchControllerApi.executeSearchTokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchTokenGet1(user?: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchTokenGet1(user, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenSearchControllerApi.executeSearchTokenGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TokenSearchControllerApi - factory interface
 * @export
 */
export const TokenSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTokenGet(token?: string, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.executeSearchTokenGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTokenGet1(user?: User, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.executeSearchTokenGet1(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenSearchControllerApi - object-oriented interface
 * @export
 * @class TokenSearchControllerApi
 * @extends {BaseAPI}
 */
export class TokenSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [token] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenSearchControllerApi
     */
    public executeSearchTokenGet(token?: string, options?: RawAxiosRequestConfig) {
        return TokenSearchControllerApiFp(this.configuration).executeSearchTokenGet(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenSearchControllerApi
     */
    public executeSearchTokenGet1(user?: User, options?: RawAxiosRequestConfig) {
        return TokenSearchControllerApiFp(this.configuration).executeSearchTokenGet1(user, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a user\'s profile image url.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserImage: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserImage', 'userId', userId)
            const localVarPath = `/user/get-user-pfp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a user\'s by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUserAsDeleted: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/delete-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user\'s basic information.
         * @param {BasicUserInfoDTO} info 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveBasicUserInfo: async (info: BasicUserInfoDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'info' is not null or undefined
            assertParamExists('saveBasicUserInfo', 'info', info)
            const localVarPath = `/user/save-user-basic-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (info !== undefined) {
                for (const [key, value] of Object.entries(info)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user\'s profile image.
         * @param {SetUserImageRequest} [setUserImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserImage: async (setUserImageRequest?: SetUserImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/upload-profile-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user info by their ID.
         * @param {UpdateUserDTO} userNewInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userNewInfo: UpdateUserDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userNewInfo' is not null or undefined
            assertParamExists('updateUser', 'userNewInfo', userNewInfo)
            const localVarPath = `/user/update-user-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userNewInfo !== undefined) {
                for (const [key, value] of Object.entries(userNewInfo)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserControllerApi.getUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a user\'s profile image url.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserImage(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserImage(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserControllerApi.getUserImage']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a user\'s by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markUserAsDeleted(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markUserAsDeleted(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserControllerApi.markUserAsDeleted']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a user\'s basic information.
         * @param {BasicUserInfoDTO} info 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveBasicUserInfo(info: BasicUserInfoDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveBasicUserInfo(info, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserControllerApi.saveBasicUserInfo']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a user\'s profile image.
         * @param {SetUserImageRequest} [setUserImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserImage(setUserImageRequest?: SetUserImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserImage(setUserImageRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserControllerApi.setUserImage']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a user info by their ID.
         * @param {UpdateUserDTO} userNewInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userNewInfo: UpdateUserDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userNewInfo, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserControllerApi.updateUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<User> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a user\'s profile image url.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserImage(userId: number, options?: any): AxiosPromise<string> {
            return localVarFp.getUserImage(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a user\'s by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUserAsDeleted(options?: any): AxiosPromise<User> {
            return localVarFp.markUserAsDeleted(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user\'s basic information.
         * @param {BasicUserInfoDTO} info 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveBasicUserInfo(info: BasicUserInfoDTO, options?: any): AxiosPromise<User> {
            return localVarFp.saveBasicUserInfo(info, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user\'s profile image.
         * @param {SetUserImageRequest} [setUserImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserImage(setUserImageRequest?: SetUserImageRequest, options?: any): AxiosPromise<string> {
            return localVarFp.setUserImage(setUserImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user info by their ID.
         * @param {UpdateUserDTO} userNewInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userNewInfo: UpdateUserDTO, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(userNewInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @summary Gets a user\'s information by their ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUser(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a user\'s profile image url.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserImage(userId: number, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getUserImage(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a user\'s by their ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public markUserAsDeleted(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).markUserAsDeleted(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user\'s basic information.
     * @param {BasicUserInfoDTO} info 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public saveBasicUserInfo(info: BasicUserInfoDTO, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).saveBasicUserInfo(info, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user\'s profile image.
     * @param {SetUserImageRequest} [setUserImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public setUserImage(setUserImageRequest?: SetUserImageRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).setUserImage(setUserImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user info by their ID.
     * @param {UpdateUserDTO} userNewInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updateUser(userNewInfo: UpdateUserDTO, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).updateUser(userNewInfo, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserEntityControllerApi - axios parameter creator
 * @export
 */
export const UserEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceUserDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceUserDelete', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceUserGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceUserGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceUserGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceUserPatch: async (id: string, userRequestBody: UserRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceUserPatch', 'id', id)
            // verify required parameter 'userRequestBody' is not null or undefined
            assertParamExists('patchItemResourceUserPatch', 'userRequestBody', userRequestBody)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-user
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceUserPost: async (userRequestBody: UserRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceUserPost', 'userRequestBody', userRequestBody)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceUserPut: async (id: string, userRequestBody: UserRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceUserPut', 'id', id)
            // verify required parameter 'userRequestBody' is not null or undefined
            assertParamExists('putItemResourceUserPut', 'userRequestBody', userRequestBody)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserEntityControllerApi - functional programming interface
 * @export
 */
export const UserEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceUserDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceUserDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.deleteItemResourceUserDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceUserGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceUserGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.getCollectionResourceUserGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceUserGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceUserGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.getItemResourceUserGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceUserPatch(id: string, userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceUserPatch(id, userRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.patchItemResourceUserPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-user
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceUserPost(userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceUserPost(userRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.postCollectionResourceUserPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceUserPut(id: string, userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceUserPut(id, userRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.putItemResourceUserPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserEntityControllerApi - factory interface
 * @export
 */
export const UserEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserEntityControllerApiFp(configuration)
    return {
        /**
         * delete-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceUserDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceUserDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceUserGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelUser> {
            return localVarFp.getCollectionResourceUserGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceUserGet(id: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.getItemResourceUserGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceUserPatch(id: string, userRequestBody: UserRequestBody, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.patchItemResourceUserPatch(id, userRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-user
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceUserPost(userRequestBody: UserRequestBody, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.postCollectionResourceUserPost(userRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceUserPut(id: string, userRequestBody: UserRequestBody, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.putItemResourceUserPut(id, userRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserEntityControllerApi - object-oriented interface
 * @export
 * @class UserEntityControllerApi
 * @extends {BaseAPI}
 */
export class UserEntityControllerApi extends BaseAPI {
    /**
     * delete-user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public deleteItemResourceUserDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).deleteItemResourceUserDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public getCollectionResourceUserGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).getCollectionResourceUserGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public getItemResourceUserGet(id: string, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).getItemResourceUserGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-user
     * @param {string} id 
     * @param {UserRequestBody} userRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public patchItemResourceUserPatch(id: string, userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).patchItemResourceUserPatch(id, userRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-user
     * @param {UserRequestBody} userRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public postCollectionResourceUserPost(userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).postCollectionResourceUserPost(userRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-user
     * @param {string} id 
     * @param {UserRequestBody} userRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public putItemResourceUserPut(id: string, userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).putItemResourceUserPut(id, userRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserPropertyReferenceControllerApi - axios parameter creator
 * @export
 */
export const UserPropertyReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * patch-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPatch: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserPatch', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserPatch', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/users/{id}/pass`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPatch1: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserPatch1', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserPatch1', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/users/{id}/wallet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPut: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserPut', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserPut', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/users/{id}/pass`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPut1: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserPut1', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserPut1', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/users/{id}/wallet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserDelete: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserDelete', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserDelete', 'propertyId', propertyId)
            const localVarPath = `/users/{id}/pass/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserDelete1: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserDelete1', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserDelete1', 'propertyId', propertyId)
            const localVarPath = `/users/{id}/wallet/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceUserDelete', 'id', id)
            const localVarPath = `/users/{id}/pass`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserDelete1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceUserDelete1', 'id', id)
            const localVarPath = `/users/{id}/wallet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet', 'propertyId', propertyId)
            const localVarPath = `/users/{id}/pass/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet1', 'id', id)
            const localVarPath = `/users/{id}/pass`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet2: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet2', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet2', 'propertyId', propertyId)
            const localVarPath = `/users/{id}/wallet/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet21: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet21', 'id', id)
            const localVarPath = `/users/{id}/wallet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPropertyReferenceControllerApi - functional programming interface
 * @export
 */
export const UserPropertyReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPropertyReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * patch-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserPatch(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.createPropertyReferenceUserPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserPatch1(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserPatch1(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.createPropertyReferenceUserPatch1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserPut(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.createPropertyReferenceUserPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserPut1(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserPut1(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.createPropertyReferenceUserPut1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdUserDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdUserDelete(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.deletePropertyReferenceIdUserDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdUserDelete1(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdUserDelete1(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.deletePropertyReferenceIdUserDelete1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceUserDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceUserDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.deletePropertyReferenceUserDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceUserDelete1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceUserDelete1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.deletePropertyReferenceUserDelete1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserGet(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.followPropertyReferenceUserGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserGet1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserGet1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.followPropertyReferenceUserGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserGet2(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserGet2(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.followPropertyReferenceUserGet2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserGet21(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserGet21(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.followPropertyReferenceUserGet21']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserPropertyReferenceControllerApi - factory interface
 * @export
 */
export const UserPropertyReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPropertyReferenceControllerApiFp(configuration)
    return {
        /**
         * patch-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPatch(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.createPropertyReferenceUserPatch(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPatch1(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.createPropertyReferenceUserPatch1(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPut(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.createPropertyReferenceUserPut(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPut1(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.createPropertyReferenceUserPut1(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserDelete(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdUserDelete(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserDelete1(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdUserDelete1(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceUserDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserDelete1(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceUserDelete1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.followPropertyReferenceUserGet(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet1(id: string, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.followPropertyReferenceUserGet1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet2(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.followPropertyReferenceUserGet2(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet21(id: string, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.followPropertyReferenceUserGet21(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPropertyReferenceControllerApi - object-oriented interface
 * @export
 * @class UserPropertyReferenceControllerApi
 * @extends {BaseAPI}
 */
export class UserPropertyReferenceControllerApi extends BaseAPI {
    /**
     * patch-pass-by-user-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserPatch(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-userwallet-by-user-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserPatch1(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserPatch1(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-pass-by-user-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserPut(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-userwallet-by-user-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserPut1(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserPut1(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-pass-by-user-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdUserDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdUserDelete(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-userwallet-by-user-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdUserDelete1(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdUserDelete1(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-pass-by-user-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public deletePropertyReferenceUserDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceUserDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-userwallet-by-user-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public deletePropertyReferenceUserDelete1(id: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceUserDelete1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-pass-by-user-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserGet(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserGet(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-pass-by-user-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserGet1(id: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserGet1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-userwallet-by-user-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserGet2(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserGet2(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-userwallet-by-user-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserGet21(id: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserGet21(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserSearchControllerApi - axios parameter creator
 * @export
 */
export const UserSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet: async (email?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/existsByEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet1: async (email?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/findByEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet2: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/findProfileImageUrlById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet3: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/getAllScanners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [busNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet4: async (busNumber?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/getBusByBusNumber`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (busNumber !== undefined) {
                localVarQueryParameter['busNumber'] = busNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet5: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/getUserById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSearchControllerApi - functional programming interface
 * @export
 */
export const UserSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserGet(email?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserGet(email, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchControllerApi.executeSearchUserGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserGet1(email?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserGet1(email, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchControllerApi.executeSearchUserGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserGet2(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserGet2(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchControllerApi.executeSearchUserGet2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserGet3(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionModelEntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserGet3(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchControllerApi.executeSearchUserGet3']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} [busNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserGet4(busNumber?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserGet4(busNumber, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchControllerApi.executeSearchUserGet4']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserGet5(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserGet5(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchControllerApi.executeSearchUserGet5']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserSearchControllerApi - factory interface
 * @export
 */
export const UserSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet(email?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.executeSearchUserGet(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet1(email?: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.executeSearchUserGet1(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet2(id?: number, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.executeSearchUserGet2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet3(options?: any): AxiosPromise<CollectionModelEntityModelUser> {
            return localVarFp.executeSearchUserGet3(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [busNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet4(busNumber?: number, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.executeSearchUserGet4(busNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet5(id?: number, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.executeSearchUserGet5(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSearchControllerApi - object-oriented interface
 * @export
 * @class UserSearchControllerApi
 * @extends {BaseAPI}
 */
export class UserSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchControllerApi
     */
    public executeSearchUserGet(email?: string, options?: RawAxiosRequestConfig) {
        return UserSearchControllerApiFp(this.configuration).executeSearchUserGet(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchControllerApi
     */
    public executeSearchUserGet1(email?: string, options?: RawAxiosRequestConfig) {
        return UserSearchControllerApiFp(this.configuration).executeSearchUserGet1(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchControllerApi
     */
    public executeSearchUserGet2(id?: number, options?: RawAxiosRequestConfig) {
        return UserSearchControllerApiFp(this.configuration).executeSearchUserGet2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchControllerApi
     */
    public executeSearchUserGet3(options?: RawAxiosRequestConfig) {
        return UserSearchControllerApiFp(this.configuration).executeSearchUserGet3(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [busNumber] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchControllerApi
     */
    public executeSearchUserGet4(busNumber?: number, options?: RawAxiosRequestConfig) {
        return UserSearchControllerApiFp(this.configuration).executeSearchUserGet4(busNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchControllerApi
     */
    public executeSearchUserGet5(id?: number, options?: RawAxiosRequestConfig) {
        return UserSearchControllerApiFp(this.configuration).executeSearchUserGet5(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserWalletEntityControllerApi - axios parameter creator
 * @export
 */
export const UserWalletEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceUserwalletDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceUserwalletDelete', 'id', id)
            const localVarPath = `/userWallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-userwallet
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceUserwalletGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userWallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceUserwalletGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceUserwalletGet', 'id', id)
            const localVarPath = `/userWallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceUserwalletPatch: async (id: string, userWalletRequestBody: UserWalletRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceUserwalletPatch', 'id', id)
            // verify required parameter 'userWalletRequestBody' is not null or undefined
            assertParamExists('patchItemResourceUserwalletPatch', 'userWalletRequestBody', userWalletRequestBody)
            const localVarPath = `/userWallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWalletRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-userwallet
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceUserwalletPost: async (userWalletRequestBody: UserWalletRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userWalletRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceUserwalletPost', 'userWalletRequestBody', userWalletRequestBody)
            const localVarPath = `/userWallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWalletRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceUserwalletPut: async (id: string, userWalletRequestBody: UserWalletRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceUserwalletPut', 'id', id)
            // verify required parameter 'userWalletRequestBody' is not null or undefined
            assertParamExists('putItemResourceUserwalletPut', 'userWalletRequestBody', userWalletRequestBody)
            const localVarPath = `/userWallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWalletRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserWalletEntityControllerApi - functional programming interface
 * @export
 */
export const UserWalletEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserWalletEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceUserwalletDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceUserwalletDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.deleteItemResourceUserwalletDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-userwallet
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceUserwalletGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceUserwalletGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.getCollectionResourceUserwalletGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceUserwalletGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceUserwalletGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.getItemResourceUserwalletGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceUserwalletPatch(id: string, userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceUserwalletPatch(id, userWalletRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.patchItemResourceUserwalletPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-userwallet
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceUserwalletPost(userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceUserwalletPost(userWalletRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.postCollectionResourceUserwalletPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceUserwalletPut(id: string, userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceUserwalletPut(id, userWalletRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.putItemResourceUserwalletPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserWalletEntityControllerApi - factory interface
 * @export
 */
export const UserWalletEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserWalletEntityControllerApiFp(configuration)
    return {
        /**
         * delete-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceUserwalletDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceUserwalletDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-userwallet
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceUserwalletGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelUserWallet> {
            return localVarFp.getCollectionResourceUserwalletGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceUserwalletGet(id: string, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.getItemResourceUserwalletGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceUserwalletPatch(id: string, userWalletRequestBody: UserWalletRequestBody, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.patchItemResourceUserwalletPatch(id, userWalletRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-userwallet
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceUserwalletPost(userWalletRequestBody: UserWalletRequestBody, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.postCollectionResourceUserwalletPost(userWalletRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceUserwalletPut(id: string, userWalletRequestBody: UserWalletRequestBody, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.putItemResourceUserwalletPut(id, userWalletRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserWalletEntityControllerApi - object-oriented interface
 * @export
 * @class UserWalletEntityControllerApi
 * @extends {BaseAPI}
 */
export class UserWalletEntityControllerApi extends BaseAPI {
    /**
     * delete-userwallet
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public deleteItemResourceUserwalletDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).deleteItemResourceUserwalletDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-userwallet
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public getCollectionResourceUserwalletGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).getCollectionResourceUserwalletGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-userwallet
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public getItemResourceUserwalletGet(id: string, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).getItemResourceUserwalletGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-userwallet
     * @param {string} id 
     * @param {UserWalletRequestBody} userWalletRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public patchItemResourceUserwalletPatch(id: string, userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).patchItemResourceUserwalletPatch(id, userWalletRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-userwallet
     * @param {UserWalletRequestBody} userWalletRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public postCollectionResourceUserwalletPost(userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).postCollectionResourceUserwalletPost(userWalletRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-userwallet
     * @param {string} id 
     * @param {UserWalletRequestBody} userWalletRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public putItemResourceUserwalletPut(id: string, userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).putItemResourceUserwalletPut(id, userWalletRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserWalletPropertyReferenceControllerApi - axios parameter creator
 * @export
 */
export const UserWalletPropertyReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * patch-membership-by-userwallet-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserwalletPatch: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserwalletPatch', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserwalletPatch', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/userWallets/{id}/membershipType`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-membership-by-userwallet-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserwalletPut: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserwalletPut', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserwalletPut', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/userWallets/{id}/membershipType`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-membership-by-userwallet-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserwalletDelete: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserwalletDelete', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserwalletDelete', 'propertyId', propertyId)
            const localVarPath = `/userWallets/{id}/membershipType/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-membership-by-userwallet-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserwalletDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceUserwalletDelete', 'id', id)
            const localVarPath = `/userWallets/{id}/membershipType`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-membership-by-userwallet-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserwalletGet: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserwalletGet', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceUserwalletGet', 'propertyId', propertyId)
            const localVarPath = `/userWallets/{id}/membershipType/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-membership-by-userwallet-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserwalletGet1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserwalletGet1', 'id', id)
            const localVarPath = `/userWallets/{id}/membershipType`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserWalletPropertyReferenceControllerApi - functional programming interface
 * @export
 */
export const UserWalletPropertyReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserWalletPropertyReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * patch-membership-by-userwallet-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserwalletPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserwalletPatch(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletPropertyReferenceControllerApi.createPropertyReferenceUserwalletPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-membership-by-userwallet-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserwalletPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserwalletPut(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletPropertyReferenceControllerApi.createPropertyReferenceUserwalletPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-membership-by-userwallet-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdUserwalletDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdUserwalletDelete(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletPropertyReferenceControllerApi.deletePropertyReferenceIdUserwalletDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-membership-by-userwallet-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceUserwalletDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceUserwalletDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletPropertyReferenceControllerApi.deletePropertyReferenceUserwalletDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-membership-by-userwallet-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserwalletGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserwalletGet(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletPropertyReferenceControllerApi.followPropertyReferenceUserwalletGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-membership-by-userwallet-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserwalletGet1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserwalletGet1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletPropertyReferenceControllerApi.followPropertyReferenceUserwalletGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserWalletPropertyReferenceControllerApi - factory interface
 * @export
 */
export const UserWalletPropertyReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserWalletPropertyReferenceControllerApiFp(configuration)
    return {
        /**
         * patch-membership-by-userwallet-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserwalletPatch(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.createPropertyReferenceUserwalletPatch(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-membership-by-userwallet-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserwalletPut(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.createPropertyReferenceUserwalletPut(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-membership-by-userwallet-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserwalletDelete(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdUserwalletDelete(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-membership-by-userwallet-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserwalletDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceUserwalletDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-membership-by-userwallet-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserwalletGet(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.followPropertyReferenceUserwalletGet(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-membership-by-userwallet-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserwalletGet1(id: string, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.followPropertyReferenceUserwalletGet1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserWalletPropertyReferenceControllerApi - object-oriented interface
 * @export
 * @class UserWalletPropertyReferenceControllerApi
 * @extends {BaseAPI}
 */
export class UserWalletPropertyReferenceControllerApi extends BaseAPI {
    /**
     * patch-membership-by-userwallet-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserwalletPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserWalletPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserwalletPatch(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-membership-by-userwallet-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserwalletPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserWalletPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserwalletPut(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-membership-by-userwallet-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletPropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdUserwalletDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserWalletPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdUserwalletDelete(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-membership-by-userwallet-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletPropertyReferenceControllerApi
     */
    public deletePropertyReferenceUserwalletDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserWalletPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceUserwalletDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-membership-by-userwallet-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserwalletGet(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserWalletPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserwalletGet(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-membership-by-userwallet-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserwalletGet1(id: string, options?: RawAxiosRequestConfig) {
        return UserWalletPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserwalletGet1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletControllerApi - axios parameter creator
 * @export
 */
export const WalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a user\'s wallet information by their ID.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletByUserId: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserWalletByUserId', 'userId', userId)
            const localVarPath = `/wallet/wallet-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletControllerApi - functional programming interface
 * @export
 */
export const WalletControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s wallet information by their ID.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletByUserId(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWalletByUserId(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WalletControllerApi.getUserWalletByUserId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * WalletControllerApi - factory interface
 * @export
 */
export const WalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s wallet information by their ID.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletByUserId(userId: number, options?: any): AxiosPromise<UserWallet> {
            return localVarFp.getUserWalletByUserId(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletControllerApi - object-oriented interface
 * @export
 * @class WalletControllerApi
 * @extends {BaseAPI}
 */
export class WalletControllerApi extends BaseAPI {
    /**
     * 
     * @summary Gets a user\'s wallet information by their ID.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getUserWalletByUserId(userId: number, options?: RawAxiosRequestConfig) {
        return WalletControllerApiFp(this.configuration).getUserWalletByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



