/* tslint:disable */
/* eslint-disable */
/**
 * OpenApi specification - AutoPass
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Contact: raphaelpaquin19@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AbstractJsonSchemaPropertyObject
 */
export interface AbstractJsonSchemaPropertyObject {
    /**
     * 
     * @type {string}
     * @memberof AbstractJsonSchemaPropertyObject
     */
    'title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AbstractJsonSchemaPropertyObject
     */
    'readOnly'?: boolean;
}
/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'businessLogo'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'businessName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'businessPrimaryColor'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'businessURL'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'chargesEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'country'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'debitNegativeBalances'?: boolean;
    /**
     * 
     * @type {AccountDeclineChargeOn}
     * @memberof Account
     */
    'declineChargeOn'?: AccountDeclineChargeOn;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'defaultCurrency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'detailsSubmitted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'displayName'?: string;
    /**
     * 
     * @type {LoginLinkCollection}
     * @memberof Account
     */
    'loginLinks'?: LoginLinkCollection;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'email'?: string;
    /**
     * 
     * @type {ExternalAccountCollection}
     * @memberof Account
     */
    'externalAccounts'?: ExternalAccountCollection;
    /**
     * 
     * @type {Keys}
     * @memberof Account
     */
    'keys'?: Keys;
    /**
     * 
     * @type {LegalEntity}
     * @memberof Account
     */
    'legalEntity'?: LegalEntity;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     * @deprecated
     */
    'managed'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Account
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'payoutsEnabled'?: boolean;
    /**
     * 
     * @type {AccountPayoutSchedule}
     * @memberof Account
     */
    'payoutSchedule'?: AccountPayoutSchedule;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'productDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'statementDescriptor'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'supportEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'supportPhone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'supportURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'timezone'?: string;
    /**
     * 
     * @type {AccountTosAcceptance}
     * @memberof Account
     */
    'tosAcceptance'?: AccountTosAcceptance;
    /**
     * 
     * @type {AccountTransferSchedule}
     * @memberof Account
     */
    'transferSchedule'?: AccountTransferSchedule;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'transfersEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'type'?: string;
    /**
     * 
     * @type {Verification}
     * @memberof Account
     */
    'verification'?: Verification;
    /**
     * 
     * @type {Array<string>}
     * @memberof Account
     * @deprecated
     */
    'currenciesSupported'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AccountDeclineChargeOn
 */
export interface AccountDeclineChargeOn {
    /**
     * 
     * @type {boolean}
     * @memberof AccountDeclineChargeOn
     */
    'avsFailure'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountDeclineChargeOn
     */
    'cvcFailure'?: boolean;
}
/**
 * 
 * @export
 * @interface AccountPayoutSchedule
 */
export interface AccountPayoutSchedule {
    /**
     * 
     * @type {number}
     * @memberof AccountPayoutSchedule
     */
    'delayDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountPayoutSchedule
     */
    'interval'?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountPayoutSchedule
     */
    'monthlyAnchor'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountPayoutSchedule
     */
    'weeklyAnchor'?: string;
}
/**
 * 
 * @export
 * @interface AccountTosAcceptance
 */
export interface AccountTosAcceptance {
    /**
     * 
     * @type {number}
     * @memberof AccountTosAcceptance
     */
    'date'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountTosAcceptance
     */
    'ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountTosAcceptance
     */
    'userAgent'?: string;
}
/**
 * 
 * @export
 * @interface AccountTransferSchedule
 */
export interface AccountTransferSchedule {
    /**
     * 
     * @type {number}
     * @memberof AccountTransferSchedule
     */
    'delayDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountTransferSchedule
     */
    'interval'?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountTransferSchedule
     */
    'monthlyAnchor'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountTransferSchedule
     */
    'weeklyAnchor'?: string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'line1'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'line2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface AlternateStatementDescriptors
 */
export interface AlternateStatementDescriptors {
    /**
     * 
     * @type {string}
     * @memberof AlternateStatementDescriptors
     */
    'kana'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlternateStatementDescriptors
     */
    'kanji'?: string;
}
/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationFee
 */
export interface ApplicationFee {
    /**
     * 
     * @type {string}
     * @memberof ApplicationFee
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFee
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFee
     */
    'account'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationFee
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationFee
     */
    'amountRefunded'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFee
     */
    'application'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFee
     */
    'balanceTransaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFee
     */
    'charge'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationFee
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFee
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationFee
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFee
     */
    'originatingTransaction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationFee
     */
    'refunded'?: boolean;
    /**
     * 
     * @type {FeeRefundCollection}
     * @memberof ApplicationFee
     */
    'refunds'?: FeeRefundCollection;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFee
     * @deprecated
     */
    'user'?: string;
    /**
     * 
     * @type {Application}
     * @memberof ApplicationFee
     */
    'applicationObject'?: Application;
    /**
     * 
     * @type {Account}
     * @memberof ApplicationFee
     */
    'accountObject'?: Account;
    /**
     * 
     * @type {Charge}
     * @memberof ApplicationFee
     */
    'originatingTransactionObject'?: Charge;
    /**
     * 
     * @type {BalanceTransaction}
     * @memberof ApplicationFee
     */
    'balanceTransactionObject'?: BalanceTransaction;
    /**
     * 
     * @type {Charge}
     * @memberof ApplicationFee
     */
    'chargeObject'?: Charge;
}
/**
 * 
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationResponse
     */
    'user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'user_email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthenticationResponse
     */
    'user_authorities'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'token_type'?: string;
}
/**
 * 
 * @export
 * @interface BalanceTransaction
 */
export interface BalanceTransaction {
    /**
     * 
     * @type {string}
     * @memberof BalanceTransaction
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceTransaction
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof BalanceTransaction
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BalanceTransaction
     */
    'availableOn'?: number;
    /**
     * 
     * @type {number}
     * @memberof BalanceTransaction
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof BalanceTransaction
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceTransaction
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof BalanceTransaction
     */
    'fee'?: number;
    /**
     * 
     * @type {Array<Fee>}
     * @memberof BalanceTransaction
     */
    'feeDetails'?: Array<Fee>;
    /**
     * 
     * @type {number}
     * @memberof BalanceTransaction
     */
    'net'?: number;
    /**
     * 
     * @type {string}
     * @memberof BalanceTransaction
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceTransaction
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceTransaction
     */
    'type'?: string;
    /**
     * 
     * @type {TransferCollection}
     * @memberof BalanceTransaction
     */
    'sourcedTransfers'?: TransferCollection;
    /**
     * 
     * @type {HasId}
     * @memberof BalanceTransaction
     */
    'sourceObjectAs'?: HasId;
    /**
     * 
     * @type {HasId}
     * @memberof BalanceTransaction
     */
    'sourceObject'?: HasId;
}
/**
 * 
 * @export
 * @interface BankAccount
 */
export interface BankAccount {
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'customer'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BankAccount
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'accountHolderName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'accountHolderType'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'bankName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BankAccount
     */
    'defaultForCurrency'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'last4'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'routingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'status'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BankAccount
     */
    'validated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'instanceURL'?: string;
}
/**
 * 
 * @export
 * @interface Card
 */
export interface Card {
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'customer'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Card
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'addressCity'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'addressCountry'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'addressLine1Check'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'addressState'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'addressZip'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'addressZipCheck'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Card
     */
    'availablePayoutMethods'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'brand'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'cvcCheck'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Card
     */
    'defaultForCurrency'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'dynamicLast4'?: string;
    /**
     * 
     * @type {number}
     * @memberof Card
     */
    'expMonth'?: number;
    /**
     * 
     * @type {number}
     * @memberof Card
     */
    'expYear'?: number;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'funding'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'last4'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'recipient'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'status'?: string;
    /**
     * 
     * @type {ThreeDSecure}
     * @memberof Card
     */
    'threeDSecure'?: ThreeDSecure;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'tokenizationMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'iin'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'issuer'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     * @deprecated
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'instanceURL'?: string;
}
/**
 * 
 * @export
 * @interface ChangePasswordDTO
 */
export interface ChangePasswordDTO {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDTO
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Charge
 */
export interface Charge {
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof Charge
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Charge
     */
    'amountRefunded'?: number;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'application'?: string;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'applicationFee'?: string;
    /**
     * 
     * @type {AlternateStatementDescriptors}
     * @memberof Charge
     */
    'alternateStatementDescriptors'?: AlternateStatementDescriptors;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'balanceTransaction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Charge
     */
    'captured'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Charge
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'customer'?: string;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'destination'?: string;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'dispute'?: string;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'failureCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'failureMessage'?: string;
    /**
     * 
     * @type {FraudDetails}
     * @memberof Charge
     */
    'fraudDetails'?: FraudDetails;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'invoice'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Charge
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Charge
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {ChargeOutcome}
     * @memberof Charge
     */
    'outcome'?: ChargeOutcome;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'order'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Charge
     */
    'paid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'receiptEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'receiptNumber'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Charge
     */
    'refunded'?: boolean;
    /**
     * 
     * @type {ChargeRefundCollection}
     * @memberof Charge
     */
    'refunds'?: ChargeRefundCollection;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'review'?: string;
    /**
     * 
     * @type {ShippingDetails}
     * @memberof Charge
     */
    'shipping'?: ShippingDetails;
    /**
     * 
     * @type {ExternalAccount}
     * @memberof Charge
     */
    'source'?: ExternalAccount;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'sourceTransfer'?: string;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'statementDescriptor'?: string;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'transfer'?: string;
    /**
     * 
     * @type {string}
     * @memberof Charge
     */
    'transferGroup'?: string;
    /**
     * 
     * @type {Card}
     * @memberof Charge
     */
    'card'?: Card;
    /**
     * 
     * @type {boolean}
     * @memberof Charge
     * @deprecated
     */
    'disputed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Charge
     * @deprecated
     */
    'statementDescription'?: string;
    /**
     * 
     * @type {Review}
     * @memberof Charge
     */
    'reviewObject'?: Review;
    /**
     * 
     * @type {Transfer}
     * @memberof Charge
     */
    'transferObject'?: Transfer;
    /**
     * 
     * @type {Order}
     * @memberof Charge
     */
    'orderObject'?: Order;
    /**
     * 
     * @type {Invoice}
     * @memberof Charge
     */
    'invoiceObject'?: Invoice;
    /**
     * 
     * @type {Customer}
     * @memberof Charge
     */
    'customerObject'?: Customer;
    /**
     * 
     * @type {Dispute}
     * @memberof Charge
     */
    'disputeObject'?: Dispute;
    /**
     * 
     * @type {Application}
     * @memberof Charge
     */
    'applicationObject'?: Application;
    /**
     * 
     * @type {Account}
     * @memberof Charge
     */
    'destinationObject'?: Account;
    /**
     * 
     * @type {ApplicationFee}
     * @memberof Charge
     */
    'applicationFeeObject'?: ApplicationFee;
    /**
     * 
     * @type {Transfer}
     * @memberof Charge
     */
    'sourceTransferObject'?: Transfer;
    /**
     * 
     * @type {BalanceTransaction}
     * @memberof Charge
     */
    'balanceTransactionObject'?: BalanceTransaction;
}
/**
 * 
 * @export
 * @interface ChargeOutcome
 */
export interface ChargeOutcome {
    /**
     * 
     * @type {string}
     * @memberof ChargeOutcome
     */
    'networkStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeOutcome
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeOutcome
     */
    'riskLevel'?: string;
    /**
     * 
     * @type {ChargeOutcomeRule}
     * @memberof ChargeOutcome
     */
    'rule'?: ChargeOutcomeRule;
    /**
     * 
     * @type {string}
     * @memberof ChargeOutcome
     */
    'sellerMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeOutcome
     */
    'type'?: string;
    /**
     * 
     * @type {ChargeOutcomeRule}
     * @memberof ChargeOutcome
     */
    'ruleObject'?: ChargeOutcomeRule;
    /**
     * 
     * @type {string}
     * @memberof ChargeOutcome
     */
    'ruleId'?: string;
}
/**
 * 
 * @export
 * @interface ChargeOutcomeRule
 */
export interface ChargeOutcomeRule {
    /**
     * 
     * @type {string}
     * @memberof ChargeOutcomeRule
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeOutcomeRule
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeOutcomeRule
     */
    'predicate'?: string;
}
/**
 * 
 * @export
 * @interface ChargeRefundCollection
 */
export interface ChargeRefundCollection {
    /**
     * 
     * @type {Array<Refund>}
     * @memberof ChargeRefundCollection
     */
    'data'?: Array<Refund>;
    /**
     * 
     * @type {number}
     * @memberof ChargeRefundCollection
     */
    'totalCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ChargeRefundCollection
     */
    'hasMore'?: boolean;
    /**
     * 
     * @type {RequestOptions}
     * @memberof ChargeRefundCollection
     */
    'requestOptions'?: RequestOptions;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ChargeRefundCollection
     */
    'requestParams'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof ChargeRefundCollection
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof ChargeRefundCollection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface CollectionModelEntityModelPaymentType
 */
export interface CollectionModelEntityModelPaymentType {
    /**
     * 
     * @type {PagedModelEntityModelPaymentTypeEmbedded}
     * @memberof CollectionModelEntityModelPaymentType
     */
    '_embedded'?: PagedModelEntityModelPaymentTypeEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof CollectionModelEntityModelPaymentType
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface CollectionModelObject
 */
export interface CollectionModelObject {
    /**
     * 
     * @type {CollectionModelObjectEmbedded}
     * @memberof CollectionModelObject
     */
    '_embedded'?: CollectionModelObjectEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof CollectionModelObject
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface CollectionModelObjectEmbedded
 */
export interface CollectionModelObjectEmbedded {
    /**
     * 
     * @type {Array<object>}
     * @memberof CollectionModelObjectEmbedded
     */
    'objects'?: Array<object>;
}
/**
 * 
 * @export
 * @interface Coupon
 */
export interface Coupon {
    /**
     * 
     * @type {string}
     * @memberof Coupon
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coupon
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof Coupon
     */
    'amountOff'?: number;
    /**
     * 
     * @type {number}
     * @memberof Coupon
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof Coupon
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coupon
     */
    'duration'?: string;
    /**
     * 
     * @type {number}
     * @memberof Coupon
     */
    'durationInMonths'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Coupon
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Coupon
     */
    'maxRedemptions'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Coupon
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof Coupon
     */
    'percentOff'?: number;
    /**
     * 
     * @type {number}
     * @memberof Coupon
     */
    'redeemBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof Coupon
     */
    'timesRedeemed'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Coupon
     */
    'valid'?: boolean;
}
/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof Customer
     */
    'accountBalance'?: number;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'businessVatId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Customer
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'defaultSource'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Customer
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Customer
     */
    'delinquent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'description'?: string;
    /**
     * 
     * @type {Discount}
     * @memberof Customer
     */
    'discount'?: Discount;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Customer
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Customer
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {ShippingDetails}
     * @memberof Customer
     */
    'shipping'?: ShippingDetails;
    /**
     * 
     * @type {ExternalAccountCollection}
     * @memberof Customer
     */
    'sources'?: ExternalAccountCollection;
    /**
     * 
     * @type {CustomerSubscriptionCollection}
     * @memberof Customer
     */
    'subscriptions'?: CustomerSubscriptionCollection;
    /**
     * 
     * @type {CustomerCardCollection}
     * @memberof Customer
     */
    'cards'?: CustomerCardCollection;
    /**
     * 
     * @type {string}
     * @memberof Customer
     * @deprecated
     */
    'defaultCard'?: string;
    /**
     * 
     * @type {NextRecurringCharge}
     * @memberof Customer
     */
    'nextRecurringCharge'?: NextRecurringCharge;
    /**
     * 
     * @type {Subscription}
     * @memberof Customer
     */
    'subscription'?: Subscription;
    /**
     * 
     * @type {number}
     * @memberof Customer
     * @deprecated
     */
    'trialEnd'?: number;
    /**
     * 
     * @type {ExternalAccount}
     * @memberof Customer
     */
    'defaultSourceObject'?: ExternalAccount;
}
/**
 * 
 * @export
 * @interface CustomerCardCollection
 */
export interface CustomerCardCollection {
    /**
     * 
     * @type {Array<Card>}
     * @memberof CustomerCardCollection
     */
    'data'?: Array<Card>;
    /**
     * 
     * @type {number}
     * @memberof CustomerCardCollection
     */
    'totalCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerCardCollection
     */
    'hasMore'?: boolean;
    /**
     * 
     * @type {RequestOptions}
     * @memberof CustomerCardCollection
     */
    'requestOptions'?: RequestOptions;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof CustomerCardCollection
     */
    'requestParams'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof CustomerCardCollection
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerCardCollection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface CustomerSubscriptionCollection
 */
export interface CustomerSubscriptionCollection {
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof CustomerSubscriptionCollection
     */
    'data'?: Array<Subscription>;
    /**
     * 
     * @type {number}
     * @memberof CustomerSubscriptionCollection
     */
    'totalCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerSubscriptionCollection
     */
    'hasMore'?: boolean;
    /**
     * 
     * @type {RequestOptions}
     * @memberof CustomerSubscriptionCollection
     */
    'requestOptions'?: RequestOptions;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof CustomerSubscriptionCollection
     */
    'requestParams'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof CustomerSubscriptionCollection
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerSubscriptionCollection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface DateOfBirth
 */
export interface DateOfBirth {
    /**
     * 
     * @type {number}
     * @memberof DateOfBirth
     */
    'day'?: number;
    /**
     * 
     * @type {number}
     * @memberof DateOfBirth
     */
    'month'?: number;
    /**
     * 
     * @type {number}
     * @memberof DateOfBirth
     */
    'year'?: number;
}
/**
 * 
 * @export
 * @interface Discount
 */
export interface Discount {
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    'object'?: string;
    /**
     * 
     * @type {Coupon}
     * @memberof Discount
     */
    'coupon'?: Coupon;
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    'customer'?: string;
    /**
     * 
     * @type {number}
     * @memberof Discount
     */
    'end'?: number;
    /**
     * 
     * @type {number}
     * @memberof Discount
     */
    'start'?: number;
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    'subscription'?: string;
}
/**
 * 
 * @export
 * @interface Dispute
 */
export interface Dispute {
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof Dispute
     */
    'amount'?: number;
    /**
     * 
     * @type {Array<BalanceTransaction>}
     * @memberof Dispute
     */
    'balanceTransactions'?: Array<BalanceTransaction>;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'charge'?: string;
    /**
     * 
     * @type {number}
     * @memberof Dispute
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'currency'?: string;
    /**
     * 
     * @type {EvidenceSubObject}
     * @memberof Dispute
     */
    'evidenceSubObject'?: EvidenceSubObject;
    /**
     * 
     * @type {EvidenceDetails}
     * @memberof Dispute
     */
    'evidenceDetails'?: EvidenceDetails;
    /**
     * 
     * @type {boolean}
     * @memberof Dispute
     */
    'isChargeRefundable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Dispute
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Dispute
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'networkReasonCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     * @deprecated
     */
    'balanceTransaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     * @deprecated
     */
    'evidence'?: string;
    /**
     * 
     * @type {number}
     * @memberof Dispute
     * @deprecated
     */
    'evidenceDueBy'?: number;
}
/**
 * 
 * @export
 * @interface EntityModelMembership
 */
export interface EntityModelMembership {
    /**
     * 
     * @type {number}
     * @memberof EntityModelMembership
     */
    'membershipDurationDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntityModelMembership
     */
    'price'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelMembership
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelMembership
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelPass
 */
export interface EntityModelPass {
    /**
     * 
     * @type {string}
     * @memberof EntityModelPass
     */
    'pass'?: string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelPass
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelPaymentType
 */
export interface EntityModelPaymentType {
    /**
     * 
     * @type {string}
     * @memberof EntityModelPaymentType
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelPaymentType
     */
    'cvv'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelPaymentType
     */
    'pan'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelPaymentType
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelPaymentType
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelTicket
 */
export interface EntityModelTicket {
    /**
     * 
     * @type {number}
     * @memberof EntityModelTicket
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntityModelTicket
     */
    'price'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelTicket
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelTicket
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelToken
 */
export interface EntityModelToken {
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelToken
     */
    'revoked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityModelToken
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelToken
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelToken
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelUser
 */
export interface EntityModelUser {
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'role'?: EntityModelUserRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'googleAccessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'profileImageUrl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'isProfileImageChanged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUser
     */
    'username'?: string;
    /**
     * 
     * @type {Array<GrantedAuthority>}
     * @memberof EntityModelUser
     */
    'authorities'?: Array<GrantedAuthority>;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'accountNonLocked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'credentialsNonExpired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'accountNonExpired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUser
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelUser
     */
    '_links'?: { [key: string]: Link; };
}

export const EntityModelUserRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER',
    GoogleUser: 'GOOGLE_USER'
} as const;

export type EntityModelUserRoleEnum = typeof EntityModelUserRoleEnum[keyof typeof EntityModelUserRoleEnum];

/**
 * 
 * @export
 * @interface EntityModelUserWallet
 */
export interface EntityModelUserWallet {
    /**
     * 
     * @type {number}
     * @memberof EntityModelUserWallet
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntityModelUserWallet
     */
    'memberShipEnds'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelUserWallet
     */
    'membershipActive'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelUserWallet
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'path'?: string;
    /**
     * 
     * @type {Array<ErrorResponseStackTraceElementsInner>}
     * @memberof ErrorResponse
     */
    'stackTraceElements'?: Array<ErrorResponseStackTraceElementsInner>;
}
/**
 * 
 * @export
 * @interface ErrorResponseStackTraceElementsInner
 */
export interface ErrorResponseStackTraceElementsInner {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'classLoaderName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'moduleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'moduleVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'methodName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'fileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'lineNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'className'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ErrorResponseStackTraceElementsInner
     */
    'nativeMethod'?: boolean;
}
/**
 * 
 * @export
 * @interface EvidenceDetails
 */
export interface EvidenceDetails {
    /**
     * 
     * @type {number}
     * @memberof EvidenceDetails
     */
    'dueBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof EvidenceDetails
     */
    'submissionCount'?: number;
}
/**
 * 
 * @export
 * @interface EvidenceSubObject
 */
export interface EvidenceSubObject {
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'productDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'customerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'customerEmailAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'customerPurchaseIp'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'billingAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'receipt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'shippingAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'shippingDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'shippingTrackingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'customerSignature'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'shippingDocumentation'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'accessActivityLog'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'serviceDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'serviceDocumentation'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'customerCommunication'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'duplicateChargeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'duplicateChargeExplanation'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'duplicateChargeDocumentation'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'refundPolicy'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'refundPolicyDisclosure'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'refundRefusalExplanation'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'cancellationPolicy'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'cancellationPolicyDisclosure'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'cancellationRebuttal'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'uncategorizedText'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceSubObject
     */
    'uncategorizedFile'?: string;
}
/**
 * 
 * @export
 * @interface ExternalAccount
 */
export interface ExternalAccount {
    /**
     * 
     * @type {string}
     * @memberof ExternalAccount
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalAccount
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalAccount
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalAccount
     */
    'customer'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ExternalAccount
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ExternalAccount
     */
    'instanceURL'?: string;
}
/**
 * 
 * @export
 * @interface ExternalAccountCollection
 */
export interface ExternalAccountCollection {
    /**
     * 
     * @type {Array<ExternalAccount>}
     * @memberof ExternalAccountCollection
     */
    'data'?: Array<ExternalAccount>;
    /**
     * 
     * @type {number}
     * @memberof ExternalAccountCollection
     */
    'totalCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExternalAccountCollection
     */
    'hasMore'?: boolean;
    /**
     * 
     * @type {RequestOptions}
     * @memberof ExternalAccountCollection
     */
    'requestOptions'?: RequestOptions;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ExternalAccountCollection
     */
    'requestParams'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof ExternalAccountCollection
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExternalAccountCollection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface Fee
 */
export interface Fee {
    /**
     * 
     * @type {number}
     * @memberof Fee
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Fee
     */
    'application'?: string;
    /**
     * 
     * @type {string}
     * @memberof Fee
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Fee
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Fee
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface FeeRefund
 */
export interface FeeRefund {
    /**
     * 
     * @type {string}
     * @memberof FeeRefund
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeRefund
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof FeeRefund
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof FeeRefund
     */
    'balanceTransaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeRefund
     */
    'currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof FeeRefund
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof FeeRefund
     */
    'fee'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FeeRefund
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {ApplicationFee}
     * @memberof FeeRefund
     */
    'feeObject'?: ApplicationFee;
    /**
     * 
     * @type {BalanceTransaction}
     * @memberof FeeRefund
     */
    'balanceTransactionObject'?: BalanceTransaction;
    /**
     * 
     * @type {string}
     * @memberof FeeRefund
     */
    'instanceURL'?: string;
}
/**
 * 
 * @export
 * @interface FeeRefundCollection
 */
export interface FeeRefundCollection {
    /**
     * 
     * @type {Array<FeeRefund>}
     * @memberof FeeRefundCollection
     */
    'data'?: Array<FeeRefund>;
    /**
     * 
     * @type {number}
     * @memberof FeeRefundCollection
     */
    'totalCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FeeRefundCollection
     */
    'hasMore'?: boolean;
    /**
     * 
     * @type {RequestOptions}
     * @memberof FeeRefundCollection
     */
    'requestOptions'?: RequestOptions;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof FeeRefundCollection
     */
    'requestParams'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof FeeRefundCollection
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof FeeRefundCollection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface FraudDetails
 */
export interface FraudDetails {
    /**
     * 
     * @type {string}
     * @memberof FraudDetails
     */
    'userReport'?: string;
    /**
     * 
     * @type {string}
     * @memberof FraudDetails
     */
    'stripeReport'?: string;
}
/**
 * 
 * @export
 * @interface GrantedAuthority
 */
export interface GrantedAuthority {
    /**
     * 
     * @type {string}
     * @memberof GrantedAuthority
     */
    'authority'?: string;
}
/**
 * 
 * @export
 * @interface HasId
 */
export interface HasId {
    /**
     * 
     * @type {string}
     * @memberof HasId
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'amountDue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'applicationFee'?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'attemptCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Invoice
     */
    'attempted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'billing'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'charge'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Invoice
     */
    'closed'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'customer'?: string;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'date'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'description'?: string;
    /**
     * 
     * @type {Discount}
     * @memberof Invoice
     */
    'discount'?: Discount;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'dueDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'endingBalance'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Invoice
     */
    'forgiven'?: boolean;
    /**
     * 
     * @type {InvoiceLineItemCollection}
     * @memberof Invoice
     */
    'lines'?: InvoiceLineItemCollection;
    /**
     * 
     * @type {boolean}
     * @memberof Invoice
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Invoice
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'nextPaymentAttempt'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'number'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Invoice
     */
    'paid'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'periodEnd'?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'periodStart'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'receiptNumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'startingBalance'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'statementDescriptor'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'subscription'?: string;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'subscriptionProrationDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'subtotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'tax'?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'taxPercent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'webhooksDeliveredAt'?: number;
    /**
     * 
     * @type {Subscription}
     * @memberof Invoice
     */
    'subscriptionObject'?: Subscription;
    /**
     * 
     * @type {Charge}
     * @memberof Invoice
     */
    'chargeObject'?: Charge;
}
/**
 * 
 * @export
 * @interface InvoiceLineItem
 */
export interface InvoiceLineItem {
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItem
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceLineItem
     */
    'discountable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceLineItem
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InvoiceLineItem
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {InvoiceLineItemPeriod}
     * @memberof InvoiceLineItem
     */
    'period'?: InvoiceLineItemPeriod;
    /**
     * 
     * @type {Plan}
     * @memberof InvoiceLineItem
     */
    'plan'?: Plan;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceLineItem
     */
    'proration'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'subscription'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface InvoiceLineItemCollection
 */
export interface InvoiceLineItemCollection {
    /**
     * 
     * @type {Array<InvoiceLineItem>}
     * @memberof InvoiceLineItemCollection
     */
    'data'?: Array<InvoiceLineItem>;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItemCollection
     */
    'totalCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceLineItemCollection
     */
    'hasMore'?: boolean;
    /**
     * 
     * @type {RequestOptions}
     * @memberof InvoiceLineItemCollection
     */
    'requestOptions'?: RequestOptions;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof InvoiceLineItemCollection
     */
    'requestParams'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItemCollection
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItemCollection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface InvoiceLineItemPeriod
 */
export interface InvoiceLineItemPeriod {
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItemPeriod
     */
    'end'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItemPeriod
     */
    'start'?: number;
}
/**
 * 
 * @export
 * @interface IsLoggedInDTO
 */
export interface IsLoggedInDTO {
    /**
     * 
     * @type {string}
     * @memberof IsLoggedInDTO
     */
    'accessToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof IsLoggedInDTO
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: AbstractJsonSchemaPropertyObject; }}
     * @memberof Item
     */
    'properties'?: { [key: string]: AbstractJsonSchemaPropertyObject; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Item
     */
    'requiredProperties'?: Array<string>;
}
/**
 * 
 * @export
 * @interface JsonSchema
 */
export interface JsonSchema {
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: AbstractJsonSchemaPropertyObject; }}
     * @memberof JsonSchema
     */
    'properties'?: { [key: string]: AbstractJsonSchemaPropertyObject; };
    /**
     * 
     * @type {Array<string>}
     * @memberof JsonSchema
     */
    'requiredProperties'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: Item; }}
     * @memberof JsonSchema
     */
    'definitions'?: { [key: string]: Item; };
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    '$schema'?: string;
}
/**
 * 
 * @export
 * @interface Keys
 */
export interface Keys {
    /**
     * 
     * @type {string}
     * @memberof Keys
     */
    'publishable'?: string;
    /**
     * 
     * @type {string}
     * @memberof Keys
     */
    'secret'?: string;
}
/**
 * 
 * @export
 * @interface LegalEntity
 */
export interface LegalEntity {
    /**
     * 
     * @type {Array<Owner>}
     * @memberof LegalEntity
     */
    'additionalOwners'?: Array<Owner>;
    /**
     * 
     * @type {Address}
     * @memberof LegalEntity
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof LegalEntity
     */
    'businessName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LegalEntity
     */
    'businessTaxIdProvided'?: boolean;
    /**
     * 
     * @type {DateOfBirth}
     * @memberof LegalEntity
     */
    'dob'?: DateOfBirth;
    /**
     * 
     * @type {string}
     * @memberof LegalEntity
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof LegalEntity
     */
    'lastName'?: string;
    /**
     * 
     * @type {Address}
     * @memberof LegalEntity
     */
    'personalAddress'?: Address;
    /**
     * 
     * @type {boolean}
     * @memberof LegalEntity
     */
    'personalIdNumberProvided'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LegalEntity
     */
    'ssnLast4Provided'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LegalEntity
     */
    'type'?: string;
    /**
     * 
     * @type {Verification}
     * @memberof LegalEntity
     */
    'verification'?: Verification;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'hreflang'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'deprecation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Link
     */
    'templated'?: boolean;
}
/**
 * 
 * @export
 * @interface LoginLink
 */
export interface LoginLink {
    /**
     * 
     * @type {string}
     * @memberof LoginLink
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoginLink
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoginLink
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginLink
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface LoginLinkCollection
 */
export interface LoginLinkCollection {
    /**
     * 
     * @type {Array<LoginLink>}
     * @memberof LoginLinkCollection
     */
    'data'?: Array<LoginLink>;
    /**
     * 
     * @type {number}
     * @memberof LoginLinkCollection
     */
    'totalCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LoginLinkCollection
     */
    'hasMore'?: boolean;
    /**
     * 
     * @type {RequestOptions}
     * @memberof LoginLinkCollection
     */
    'requestOptions'?: RequestOptions;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof LoginLinkCollection
     */
    'requestParams'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof LoginLinkCollection
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoginLinkCollection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface Membership
 */
export interface Membership {
    /**
     * 
     * @type {number}
     * @memberof Membership
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Membership
     */
    'membershipDurationDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof Membership
     */
    'price'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Membership
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface MembershipRequestBody
 */
export interface MembershipRequestBody {
    /**
     * 
     * @type {number}
     * @memberof MembershipRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof MembershipRequestBody
     */
    'membershipDurationDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof MembershipRequestBody
     */
    'price'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MembershipRequestBody
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface NextRecurringCharge
 */
export interface NextRecurringCharge {
    /**
     * 
     * @type {number}
     * @memberof NextRecurringCharge
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof NextRecurringCharge
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'amountReturned'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'application'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'applicationFee'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'charge'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'customer'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'externalCouponCode'?: string;
    /**
     * 
     * @type {Array<OrderItem>}
     * @memberof Order
     */
    'items'?: Array<OrderItem>;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Order
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {OrderReturnCollection}
     * @memberof Order
     */
    'returns'?: OrderReturnCollection;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'selectedShippingMethod'?: string;
    /**
     * 
     * @type {ShippingDetails}
     * @memberof Order
     */
    'shipping'?: ShippingDetails;
    /**
     * 
     * @type {Array<ShippingMethod>}
     * @memberof Order
     */
    'shippingMethods'?: Array<ShippingMethod>;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'status'?: string;
    /**
     * 
     * @type {StatusTransitions}
     * @memberof Order
     */
    'statusTransitions'?: StatusTransitions;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'updated'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'upstreamId'?: string;
    /**
     * 
     * @type {Customer}
     * @memberof Order
     */
    'customerObject'?: Customer;
    /**
     * 
     * @type {Charge}
     * @memberof Order
     */
    'chargeObject'?: Charge;
}
/**
 * 
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderItem
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'parent'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'type'?: string;
    /**
     * 
     * @type {HasId}
     * @memberof OrderItem
     */
    'parentObject'?: HasId;
    /**
     * 
     * @type {HasId}
     * @memberof OrderItem
     */
    'parentObjectAs'?: HasId;
}
/**
 * 
 * @export
 * @interface OrderReturn
 */
export interface OrderReturn {
    /**
     * 
     * @type {string}
     * @memberof OrderReturn
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderReturn
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderReturn
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderReturn
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderReturn
     */
    'currency'?: string;
    /**
     * 
     * @type {Array<OrderItem>}
     * @memberof OrderReturn
     */
    'items'?: Array<OrderItem>;
    /**
     * 
     * @type {boolean}
     * @memberof OrderReturn
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderReturn
     */
    'order'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderReturn
     */
    'refund'?: string;
    /**
     * 
     * @type {Refund}
     * @memberof OrderReturn
     */
    'refundObject'?: Refund;
    /**
     * 
     * @type {Order}
     * @memberof OrderReturn
     */
    'orderObject'?: Order;
}
/**
 * 
 * @export
 * @interface OrderReturnCollection
 */
export interface OrderReturnCollection {
    /**
     * 
     * @type {Array<OrderReturn>}
     * @memberof OrderReturnCollection
     */
    'data'?: Array<OrderReturn>;
    /**
     * 
     * @type {number}
     * @memberof OrderReturnCollection
     */
    'totalCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderReturnCollection
     */
    'hasMore'?: boolean;
    /**
     * 
     * @type {RequestOptions}
     * @memberof OrderReturnCollection
     */
    'requestOptions'?: RequestOptions;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof OrderReturnCollection
     */
    'requestParams'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof OrderReturnCollection
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderReturnCollection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface Owner
 */
export interface Owner {
    /**
     * 
     * @type {Address}
     * @memberof Owner
     */
    'address'?: Address;
    /**
     * 
     * @type {DateOfBirth}
     * @memberof Owner
     */
    'dob'?: DateOfBirth;
    /**
     * 
     * @type {string}
     * @memberof Owner
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Owner
     */
    'lastName'?: string;
    /**
     * 
     * @type {Verification}
     * @memberof Owner
     */
    'verification'?: Verification;
}
/**
 * 
 * @export
 * @interface PageMetadata
 */
export interface PageMetadata {
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelMembership
 */
export interface PagedModelEntityModelMembership {
    /**
     * 
     * @type {PagedModelEntityModelMembershipEmbedded}
     * @memberof PagedModelEntityModelMembership
     */
    '_embedded'?: PagedModelEntityModelMembershipEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelMembership
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelMembership
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelMembershipEmbedded
 */
export interface PagedModelEntityModelMembershipEmbedded {
    /**
     * 
     * @type {Array<EntityModelMembership>}
     * @memberof PagedModelEntityModelMembershipEmbedded
     */
    'memberships'?: Array<EntityModelMembership>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPass
 */
export interface PagedModelEntityModelPass {
    /**
     * 
     * @type {PagedModelEntityModelPassEmbedded}
     * @memberof PagedModelEntityModelPass
     */
    '_embedded'?: PagedModelEntityModelPassEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelPass
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelPass
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPassEmbedded
 */
export interface PagedModelEntityModelPassEmbedded {
    /**
     * 
     * @type {Array<EntityModelPass>}
     * @memberof PagedModelEntityModelPassEmbedded
     */
    'passes'?: Array<EntityModelPass>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPaymentType
 */
export interface PagedModelEntityModelPaymentType {
    /**
     * 
     * @type {PagedModelEntityModelPaymentTypeEmbedded}
     * @memberof PagedModelEntityModelPaymentType
     */
    '_embedded'?: PagedModelEntityModelPaymentTypeEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelPaymentType
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelPaymentType
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPaymentTypeEmbedded
 */
export interface PagedModelEntityModelPaymentTypeEmbedded {
    /**
     * 
     * @type {Array<EntityModelPaymentType>}
     * @memberof PagedModelEntityModelPaymentTypeEmbedded
     */
    'paymentTypes'?: Array<EntityModelPaymentType>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelTicket
 */
export interface PagedModelEntityModelTicket {
    /**
     * 
     * @type {PagedModelEntityModelTicketEmbedded}
     * @memberof PagedModelEntityModelTicket
     */
    '_embedded'?: PagedModelEntityModelTicketEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelTicket
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelTicket
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelTicketEmbedded
 */
export interface PagedModelEntityModelTicketEmbedded {
    /**
     * 
     * @type {Array<EntityModelTicket>}
     * @memberof PagedModelEntityModelTicketEmbedded
     */
    'tickets'?: Array<EntityModelTicket>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelToken
 */
export interface PagedModelEntityModelToken {
    /**
     * 
     * @type {PagedModelEntityModelTokenEmbedded}
     * @memberof PagedModelEntityModelToken
     */
    '_embedded'?: PagedModelEntityModelTokenEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelToken
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelToken
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelTokenEmbedded
 */
export interface PagedModelEntityModelTokenEmbedded {
    /**
     * 
     * @type {Array<EntityModelToken>}
     * @memberof PagedModelEntityModelTokenEmbedded
     */
    'tokens'?: Array<EntityModelToken>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUser
 */
export interface PagedModelEntityModelUser {
    /**
     * 
     * @type {PagedModelEntityModelUserEmbedded}
     * @memberof PagedModelEntityModelUser
     */
    '_embedded'?: PagedModelEntityModelUserEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelUser
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelUser
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUserEmbedded
 */
export interface PagedModelEntityModelUserEmbedded {
    /**
     * 
     * @type {Array<EntityModelUser>}
     * @memberof PagedModelEntityModelUserEmbedded
     */
    'users'?: Array<EntityModelUser>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUserWallet
 */
export interface PagedModelEntityModelUserWallet {
    /**
     * 
     * @type {PagedModelEntityModelUserWalletEmbedded}
     * @memberof PagedModelEntityModelUserWallet
     */
    '_embedded'?: PagedModelEntityModelUserWalletEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelUserWallet
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelUserWallet
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUserWalletEmbedded
 */
export interface PagedModelEntityModelUserWalletEmbedded {
    /**
     * 
     * @type {Array<EntityModelUserWallet>}
     * @memberof PagedModelEntityModelUserWalletEmbedded
     */
    'userWallets'?: Array<EntityModelUserWallet>;
}
/**
 * 
 * @export
 * @interface Pass
 */
export interface Pass {
    /**
     * 
     * @type {number}
     * @memberof Pass
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Pass
     */
    'pass'?: string;
}
/**
 * 
 * @export
 * @interface PassRequestBody
 */
export interface PassRequestBody {
    /**
     * 
     * @type {number}
     * @memberof PassRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PassRequestBody
     */
    'pass'?: string;
}
/**
 * 
 * @export
 * @interface PaymentTypeRequestBody
 */
export interface PaymentTypeRequestBody {
    /**
     * 
     * @type {number}
     * @memberof PaymentTypeRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentTypeRequestBody
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTypeRequestBody
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTypeRequestBody
     */
    'cvv'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTypeRequestBody
     */
    'pan'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentTypeRequestBody
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface Plan
 */
export interface Plan {
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof Plan
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Plan
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    'interval'?: string;
    /**
     * 
     * @type {number}
     * @memberof Plan
     */
    'intervalCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Plan
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Plan
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    'statementDescriptor'?: string;
    /**
     * 
     * @type {number}
     * @memberof Plan
     */
    'trialPeriodDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof Plan
     * @deprecated
     */
    'statementDescription'?: string;
}
/**
 * 
 * @export
 * @interface RefreshTokenDTO
 */
export interface RefreshTokenDTO {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenDTO
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface Refund
 */
export interface Refund {
    /**
     * 
     * @type {string}
     * @memberof Refund
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Refund
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof Refund
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Refund
     */
    'balanceTransaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof Refund
     */
    'charge'?: string;
    /**
     * 
     * @type {number}
     * @memberof Refund
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof Refund
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Refund
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Refund
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Refund
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof Refund
     */
    'receiptNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Refund
     */
    'status'?: string;
    /**
     * 
     * @type {BalanceTransaction}
     * @memberof Refund
     */
    'balanceTransactionObject'?: BalanceTransaction;
    /**
     * 
     * @type {Charge}
     * @memberof Refund
     */
    'chargeObject'?: Charge;
}
/**
 * 
 * @export
 * @interface RepresentationModelObject
 */
export interface RepresentationModelObject {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof RepresentationModelObject
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface RequestOptions
 */
export interface RequestOptions {
    /**
     * 
     * @type {string}
     * @memberof RequestOptions
     */
    'apiKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestOptions
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestOptions
     */
    'stripeVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestOptions
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestOptions
     */
    'stripeAccount'?: string;
    /**
     * 
     * @type {number}
     * @memberof RequestOptions
     */
    'connectTimeout'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestOptions
     */
    'readTimeout'?: number;
}
/**
 * 
 * @export
 * @interface Reversal
 */
export interface Reversal {
    /**
     * 
     * @type {string}
     * @memberof Reversal
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Reversal
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof Reversal
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Reversal
     */
    'balanceTransaction'?: string;
    /**
     * 
     * @type {number}
     * @memberof Reversal
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof Reversal
     */
    'currency'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Reversal
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Reversal
     */
    'transfer'?: string;
    /**
     * 
     * @type {Transfer}
     * @memberof Reversal
     */
    'transferObject'?: Transfer;
    /**
     * 
     * @type {BalanceTransaction}
     * @memberof Reversal
     */
    'balanceTransactionObject'?: BalanceTransaction;
    /**
     * 
     * @type {string}
     * @memberof Reversal
     */
    'instanceURL'?: string;
}
/**
 * 
 * @export
 * @interface Review
 */
export interface Review {
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'charge'?: string;
    /**
     * 
     * @type {number}
     * @memberof Review
     */
    'created'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Review
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Review
     */
    'open'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface SetUserImageRequest
 */
export interface SetUserImageRequest {
    /**
     * 
     * @type {File}
     * @memberof SetUserImageRequest
     */
    'file': File;
}
/**
 * 
 * @export
 * @interface ShippingDetails
 */
export interface ShippingDetails {
    /**
     * 
     * @type {Address}
     * @memberof ShippingDetails
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof ShippingDetails
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingDetails
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface ShippingMethod
 */
export interface ShippingMethod {
    /**
     * 
     * @type {string}
     * @memberof ShippingMethod
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShippingMethod
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShippingMethod
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingMethod
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface SignInDTO
 */
export interface SignInDTO {
    /**
     * 
     * @type {string}
     * @memberof SignInDTO
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignInDTO
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface SignUpDTO
 */
export interface SignUpDTO {
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDTO
     */
    'role'?: SignUpDTORoleEnum;
}

export const SignUpDTORoleEnum = {
    Admin: 'ADMIN',
    User: 'USER',
    GoogleUser: 'GOOGLE_USER'
} as const;

export type SignUpDTORoleEnum = typeof SignUpDTORoleEnum[keyof typeof SignUpDTORoleEnum];

/**
 * 
 * @export
 * @interface StatusTransitions
 */
export interface StatusTransitions {
    /**
     * 
     * @type {number}
     * @memberof StatusTransitions
     */
    'canceled'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatusTransitions
     */
    'fulfiled'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatusTransitions
     */
    'paid'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatusTransitions
     */
    'returned'?: number;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'applicationFeePercent'?: number;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'billing'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Subscription
     */
    'cancelAtPeriodEnd'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'canceledAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'created'?: number;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'currentPeriodEnd'?: number;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'currentPeriodStart'?: number;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'customer'?: string;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'daysUntilDue'?: number;
    /**
     * 
     * @type {Discount}
     * @memberof Subscription
     */
    'discount'?: Discount;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'endedAt'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Subscription
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {Plan}
     * @memberof Subscription
     */
    'plan'?: Plan;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'start'?: number;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'taxPercent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'trialEnd'?: number;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'trialStart'?: number;
    /**
     * 
     * @type {Customer}
     * @memberof Subscription
     */
    'customerObject'?: Customer;
    /**
     * 
     * @type {SubscriptionItemCollection}
     * @memberof Subscription
     */
    'subscriptionItems'?: SubscriptionItemCollection;
}
/**
 * 
 * @export
 * @interface SubscriptionItem
 */
export interface SubscriptionItem {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionItem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionItem
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionItem
     */
    'created'?: number;
    /**
     * 
     * @type {Plan}
     * @memberof SubscriptionItem
     */
    'plan'?: Plan;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionItem
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface SubscriptionItemCollection
 */
export interface SubscriptionItemCollection {
    /**
     * 
     * @type {Array<SubscriptionItem>}
     * @memberof SubscriptionItemCollection
     */
    'data'?: Array<SubscriptionItem>;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionItemCollection
     */
    'totalCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionItemCollection
     */
    'hasMore'?: boolean;
    /**
     * 
     * @type {RequestOptions}
     * @memberof SubscriptionItemCollection
     */
    'requestOptions'?: RequestOptions;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SubscriptionItemCollection
     */
    'requestParams'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof SubscriptionItemCollection
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionItemCollection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface Summary
 */
export interface Summary {
    /**
     * 
     * @type {number}
     * @memberof Summary
     */
    'adjustmentCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Summary
     */
    'adjustmentGross'?: number;
    /**
     * 
     * @type {number}
     * @memberof Summary
     */
    'chargeCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Summary
     */
    'chargeFees'?: number;
    /**
     * 
     * @type {number}
     * @memberof Summary
     */
    'chargeGross'?: number;
    /**
     * 
     * @type {number}
     * @memberof Summary
     */
    'net'?: number;
    /**
     * 
     * @type {number}
     * @memberof Summary
     */
    'refundCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Summary
     */
    'refundFees'?: number;
    /**
     * 
     * @type {number}
     * @memberof Summary
     */
    'refundGross'?: number;
    /**
     * 
     * @type {number}
     * @memberof Summary
     */
    'validationCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Summary
     */
    'validationFees'?: number;
}
/**
 * 
 * @export
 * @interface ThreeDSecure
 */
export interface ThreeDSecure {
    /**
     * 
     * @type {string}
     * @memberof ThreeDSecure
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThreeDSecure
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof ThreeDSecure
     */
    'amount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ThreeDSecure
     */
    'authenticated'?: boolean;
    /**
     * 
     * @type {Card}
     * @memberof ThreeDSecure
     */
    'card'?: Card;
    /**
     * 
     * @type {number}
     * @memberof ThreeDSecure
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof ThreeDSecure
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ThreeDSecure
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ThreeDSecure
     */
    'redirectURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThreeDSecure
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface TicketRequestBody
 */
export interface TicketRequestBody {
    /**
     * 
     * @type {number}
     * @memberof TicketRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof TicketRequestBody
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof TicketRequestBody
     */
    'price'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TicketRequestBody
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenRequestBody
 */
export interface TokenRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof TokenRequestBody
     */
    'revoked'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TokenRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TokenRequestBody
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequestBody
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequestBody
     */
    'expiryDate'?: string;
}
/**
 * 
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transfer
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transfer
     */
    'amountReversed'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'applicationFee'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'balanceTransaction'?: string;
    /**
     * 
     * @type {BankAccount}
     * @memberof Transfer
     */
    'bankAccount'?: BankAccount;
    /**
     * 
     * @type {number}
     * @memberof Transfer
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transfer
     */
    'date'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'destination'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'destinationPayment'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'failureCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'failureMessage'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Transfer
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Transfer
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {TransferReversalCollection}
     * @memberof Transfer
     */
    'reversals'?: TransferReversalCollection;
    /**
     * 
     * @type {boolean}
     * @memberof Transfer
     */
    'reversed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'sourceTransaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'sourceType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'statementDescriptor'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'transferGroup'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'type'?: string;
    /**
     * 
     * @type {BankAccount}
     * @memberof Transfer
     */
    'account'?: BankAccount;
    /**
     * 
     * @type {Array<string>}
     * @memberof Transfer
     * @deprecated
     */
    'otherTransfers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'recipient'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'statementDescription'?: string;
    /**
     * 
     * @type {Summary}
     * @memberof Transfer
     */
    'summary'?: Summary;
    /**
     * 
     * @type {Charge}
     * @memberof Transfer
     */
    'sourceTransactionObject'?: Charge;
    /**
     * 
     * @type {Account}
     * @memberof Transfer
     */
    'destinationObject'?: Account;
    /**
     * 
     * @type {Charge}
     * @memberof Transfer
     */
    'destinationPaymentObject'?: Charge;
    /**
     * 
     * @type {BalanceTransaction}
     * @memberof Transfer
     */
    'balanceTransactionObject'?: BalanceTransaction;
}
/**
 * 
 * @export
 * @interface TransferCollection
 */
export interface TransferCollection {
    /**
     * 
     * @type {Array<Transfer>}
     * @memberof TransferCollection
     */
    'data'?: Array<Transfer>;
    /**
     * 
     * @type {number}
     * @memberof TransferCollection
     */
    'totalCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TransferCollection
     */
    'hasMore'?: boolean;
    /**
     * 
     * @type {RequestOptions}
     * @memberof TransferCollection
     */
    'requestOptions'?: RequestOptions;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof TransferCollection
     */
    'requestParams'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof TransferCollection
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransferCollection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface TransferReversalCollection
 */
export interface TransferReversalCollection {
    /**
     * 
     * @type {Array<Reversal>}
     * @memberof TransferReversalCollection
     */
    'data'?: Array<Reversal>;
    /**
     * 
     * @type {number}
     * @memberof TransferReversalCollection
     */
    'totalCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TransferReversalCollection
     */
    'hasMore'?: boolean;
    /**
     * 
     * @type {RequestOptions}
     * @memberof TransferReversalCollection
     */
    'requestOptions'?: RequestOptions;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof TransferReversalCollection
     */
    'requestParams'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof TransferReversalCollection
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransferReversalCollection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface UpdateUserDTO
 */
export interface UpdateUserDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDTO
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDTO
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDTO
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDTO
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {UserWallet}
     * @memberof User
     */
    'wallet'?: UserWallet;
    /**
     * 
     * @type {Pass}
     * @memberof User
     */
    'pass'?: Pass;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role'?: UserRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'googleAccessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profileImageUrl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isProfileImageChanged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {Array<GrantedAuthority>}
     * @memberof User
     */
    'authorities'?: Array<GrantedAuthority>;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'accountNonLocked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'credentialsNonExpired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'accountNonExpired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'deleted'?: boolean;
}

export const UserRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER',
    GoogleUser: 'GOOGLE_USER'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * 
 * @export
 * @interface UserRequestBody
 */
export interface UserRequestBody {
    /**
     * 
     * @type {number}
     * @memberof UserRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'wallet'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'pass'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'role'?: UserRequestBodyRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'googleAccessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'profileImageUrl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'isProfileImageChanged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    'username'?: string;
    /**
     * 
     * @type {Array<GrantedAuthority>}
     * @memberof UserRequestBody
     */
    'authorities'?: Array<GrantedAuthority>;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'accountNonLocked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'credentialsNonExpired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'accountNonExpired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequestBody
     */
    'deleted'?: boolean;
}

export const UserRequestBodyRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER',
    GoogleUser: 'GOOGLE_USER'
} as const;

export type UserRequestBodyRoleEnum = typeof UserRequestBodyRoleEnum[keyof typeof UserRequestBodyRoleEnum];

/**
 * 
 * @export
 * @interface UserWallet
 */
export interface UserWallet {
    /**
     * 
     * @type {number}
     * @memberof UserWallet
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWallet
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWallet
     */
    'memberShipEnds'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserWallet
     */
    'membershipActive'?: boolean;
    /**
     * 
     * @type {Membership}
     * @memberof UserWallet
     */
    'membershipType'?: Membership;
}
/**
 * 
 * @export
 * @interface UserWalletRequestBody
 */
export interface UserWalletRequestBody {
    /**
     * 
     * @type {number}
     * @memberof UserWalletRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWalletRequestBody
     */
    'ticketAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWalletRequestBody
     */
    'memberShipEnds'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserWalletRequestBody
     */
    'membershipActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserWalletRequestBody
     */
    'membershipType'?: string;
}
/**
 * 
 * @export
 * @interface Verification
 */
export interface Verification {
    /**
     * 
     * @type {boolean}
     * @memberof Verification
     */
    'contacted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Verification
     */
    'disabledReason'?: string;
    /**
     * 
     * @type {number}
     * @memberof Verification
     */
    'dueBy'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Verification
     */
    'fieldsNeeded'?: Array<string>;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Logs a user in by an email and password. Returns a JWT token for session handling.
         * @param {SignInDTO} signInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (signInDTO: SignInDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInDTO' is not null or undefined
            assertParamExists('authenticate', 'signInDTO', signInDTO)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Changes a user\'s password.
         * @param {ChangePasswordDTO} changePasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordDTO: ChangePasswordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordDTO' is not null or undefined
            assertParamExists('changePassword', 'changePasswordDTO', changePasswordDTO)
            const localVarPath = `/auth/update-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends an email with link to reset password.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('forgotPassword', 'email', email)
            const localVarPath = `/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if the access token is valid.
         * @param {IsLoggedInDTO} isLoggedInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isLogged: async (isLoggedInDTO: IsLoggedInDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isLoggedInDTO' is not null or undefined
            assertParamExists('isLogged', 'isLoggedInDTO', isLoggedInDTO)
            const localVarPath = `/auth/isLogged`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(isLoggedInDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if the refresh token is valid.
         * @param {RefreshTokenDTO} refreshTokenDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRefreshTokenExpired: async (refreshTokenDTO: RefreshTokenDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenDTO' is not null or undefined
            assertParamExists('isRefreshTokenExpired', 'refreshTokenDTO', refreshTokenDTO)
            const localVarPath = `/auth/check-refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This method handles user logout. It removes the refresh token associated with the user (if it exists).
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('logout', 'userId', userId)
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to refresh expired access token. Verifies if refresh token is valid.
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken: async (refreshToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('refreshAccessToken', 'refreshToken', refreshToken)
            const localVarPath = `/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refreshToken !== undefined) {
                localVarQueryParameter['refreshToken'] = refreshToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upon successful registration, it returns JWT and refresh token cookies, similar to the login process. This allows the user to immediately log in after signing up.
         * @param {SignUpDTO} signUpDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (signUpDTO: SignUpDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpDTO' is not null or undefined
            assertParamExists('register', 'signUpDTO', signUpDTO)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Logs a user in by an email and password. Returns a JWT token for session handling.
         * @param {SignInDTO} signInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(signInDTO: SignInDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(signInDTO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Changes a user\'s password.
         * @param {ChangePasswordDTO} changePasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordDTO: ChangePasswordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordDTO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.changePassword']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Sends an email with link to reset password.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(email, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.forgotPassword']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Checks if the access token is valid.
         * @param {IsLoggedInDTO} isLoggedInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isLogged(isLoggedInDTO: IsLoggedInDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isLogged(isLoggedInDTO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.isLogged']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Checks if the refresh token is valid.
         * @param {RefreshTokenDTO} refreshTokenDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isRefreshTokenExpired(refreshTokenDTO: RefreshTokenDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isRefreshTokenExpired(refreshTokenDTO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.isRefreshTokenExpired']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary This method handles user logout. It removes the refresh token associated with the user (if it exists).
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.logout']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Used to refresh expired access token. Verifies if refresh token is valid.
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAccessToken(refreshToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(refreshToken, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.refreshAccessToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Upon successful registration, it returns JWT and refresh token cookies, similar to the login process. This allows the user to immediately log in after signing up.
         * @param {SignUpDTO} signUpDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(signUpDTO: SignUpDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(signUpDTO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.register']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Logs a user in by an email and password. Returns a JWT token for session handling.
         * @param {SignInDTO} signInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(signInDTO: SignInDTO, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.authenticate(signInDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Changes a user\'s password.
         * @param {ChangePasswordDTO} changePasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordDTO: ChangePasswordDTO, options?: any): AxiosPromise<boolean> {
            return localVarFp.changePassword(changePasswordDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sends an email with link to reset password.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(email: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.forgotPassword(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Checks if the access token is valid.
         * @param {IsLoggedInDTO} isLoggedInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isLogged(isLoggedInDTO: IsLoggedInDTO, options?: any): AxiosPromise<boolean> {
            return localVarFp.isLogged(isLoggedInDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Checks if the refresh token is valid.
         * @param {RefreshTokenDTO} refreshTokenDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRefreshTokenExpired(refreshTokenDTO: RefreshTokenDTO, options?: any): AxiosPromise<boolean> {
            return localVarFp.isRefreshTokenExpired(refreshTokenDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This method handles user logout. It removes the refresh token associated with the user (if it exists).
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.logout(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to refresh expired access token. Verifies if refresh token is valid.
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(refreshToken: string, options?: any): AxiosPromise<string> {
            return localVarFp.refreshAccessToken(refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upon successful registration, it returns JWT and refresh token cookies, similar to the login process. This allows the user to immediately log in after signing up.
         * @param {SignUpDTO} signUpDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(signUpDTO: SignUpDTO, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.register(signUpDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Logs a user in by an email and password. Returns a JWT token for session handling.
     * @param {SignInDTO} signInDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticate(signInDTO: SignInDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticate(signInDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Changes a user\'s password.
     * @param {ChangePasswordDTO} changePasswordDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public changePassword(changePasswordDTO: ChangePasswordDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).changePassword(changePasswordDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sends an email with link to reset password.
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public forgotPassword(email: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).forgotPassword(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Checks if the access token is valid.
     * @param {IsLoggedInDTO} isLoggedInDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public isLogged(isLoggedInDTO: IsLoggedInDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).isLogged(isLoggedInDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Checks if the refresh token is valid.
     * @param {RefreshTokenDTO} refreshTokenDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public isRefreshTokenExpired(refreshTokenDTO: RefreshTokenDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).isRefreshTokenExpired(refreshTokenDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This method handles user logout. It removes the refresh token associated with the user (if it exists).
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(userId: number, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to refresh expired access token. Verifies if refresh token is valid.
     * @param {string} refreshToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public refreshAccessToken(refreshToken: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refreshAccessToken(refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upon successful registration, it returns JWT and refresh token cookies, similar to the login process. This allows the user to immediately log in after signing up.
     * @param {SignUpDTO} signUpDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public register(signUpDTO: SignUpDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).register(signUpDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembershipEntityControllerApi - axios parameter creator
 * @export
 */
export const MembershipEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceMembershipDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceMembershipDelete', 'id', id)
            const localVarPath = `/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-membership
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceMembershipGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceMembershipGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceMembershipGet', 'id', id)
            const localVarPath = `/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceMembershipPatch: async (id: string, membershipRequestBody: MembershipRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceMembershipPatch', 'id', id)
            // verify required parameter 'membershipRequestBody' is not null or undefined
            assertParamExists('patchItemResourceMembershipPatch', 'membershipRequestBody', membershipRequestBody)
            const localVarPath = `/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membershipRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-membership
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceMembershipPost: async (membershipRequestBody: MembershipRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'membershipRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceMembershipPost', 'membershipRequestBody', membershipRequestBody)
            const localVarPath = `/memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membershipRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceMembershipPut: async (id: string, membershipRequestBody: MembershipRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceMembershipPut', 'id', id)
            // verify required parameter 'membershipRequestBody' is not null or undefined
            assertParamExists('putItemResourceMembershipPut', 'membershipRequestBody', membershipRequestBody)
            const localVarPath = `/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membershipRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembershipEntityControllerApi - functional programming interface
 * @export
 */
export const MembershipEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembershipEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceMembershipDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceMembershipDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.deleteItemResourceMembershipDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-membership
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceMembershipGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceMembershipGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.getCollectionResourceMembershipGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceMembershipGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceMembershipGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.getItemResourceMembershipGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceMembershipPatch(id: string, membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceMembershipPatch(id, membershipRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.patchItemResourceMembershipPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-membership
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceMembershipPost(membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceMembershipPost(membershipRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.postCollectionResourceMembershipPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceMembershipPut(id: string, membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceMembershipPut(id, membershipRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MembershipEntityControllerApi.putItemResourceMembershipPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MembershipEntityControllerApi - factory interface
 * @export
 */
export const MembershipEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembershipEntityControllerApiFp(configuration)
    return {
        /**
         * delete-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceMembershipDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceMembershipDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-membership
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceMembershipGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelMembership> {
            return localVarFp.getCollectionResourceMembershipGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-membership
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceMembershipGet(id: string, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.getItemResourceMembershipGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceMembershipPatch(id: string, membershipRequestBody: MembershipRequestBody, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.patchItemResourceMembershipPatch(id, membershipRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-membership
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceMembershipPost(membershipRequestBody: MembershipRequestBody, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.postCollectionResourceMembershipPost(membershipRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-membership
         * @param {string} id 
         * @param {MembershipRequestBody} membershipRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceMembershipPut(id: string, membershipRequestBody: MembershipRequestBody, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.putItemResourceMembershipPut(id, membershipRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembershipEntityControllerApi - object-oriented interface
 * @export
 * @class MembershipEntityControllerApi
 * @extends {BaseAPI}
 */
export class MembershipEntityControllerApi extends BaseAPI {
    /**
     * delete-membership
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public deleteItemResourceMembershipDelete(id: string, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).deleteItemResourceMembershipDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-membership
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public getCollectionResourceMembershipGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).getCollectionResourceMembershipGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-membership
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public getItemResourceMembershipGet(id: string, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).getItemResourceMembershipGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-membership
     * @param {string} id 
     * @param {MembershipRequestBody} membershipRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public patchItemResourceMembershipPatch(id: string, membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).patchItemResourceMembershipPatch(id, membershipRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-membership
     * @param {MembershipRequestBody} membershipRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public postCollectionResourceMembershipPost(membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).postCollectionResourceMembershipPost(membershipRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-membership
     * @param {string} id 
     * @param {MembershipRequestBody} membershipRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipEntityControllerApi
     */
    public putItemResourceMembershipPut(id: string, membershipRequestBody: MembershipRequestBody, options?: RawAxiosRequestConfig) {
        return MembershipEntityControllerApiFp(this.configuration).putItemResourceMembershipPut(id, membershipRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OAuth2ControllerApi - axios parameter creator
 * @export
 */
export const OAuth2ControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/google/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuth2ControllerApi - functional programming interface
 * @export
 */
export const OAuth2ControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuth2ControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser1(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OAuth2ControllerApi.getUser1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OAuth2ControllerApi - factory interface
 * @export
 */
export const OAuth2ControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuth2ControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser1(options?: any): AxiosPromise<User> {
            return localVarFp.getUser1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuth2ControllerApi - object-oriented interface
 * @export
 * @class OAuth2ControllerApi
 * @extends {BaseAPI}
 */
export class OAuth2ControllerApi extends BaseAPI {
    /**
     * 
     * @summary Gets a user\'s information by their ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ControllerApi
     */
    public getUser1(options?: RawAxiosRequestConfig) {
        return OAuth2ControllerApiFp(this.configuration).getUser1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PassEntityControllerApi - axios parameter creator
 * @export
 */
export const PassEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourcePassDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourcePassDelete', 'id', id)
            const localVarPath = `/passes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-pass
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourcePassGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/passes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourcePassGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourcePassGet', 'id', id)
            const localVarPath = `/passes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourcePassPatch: async (id: string, passRequestBody: PassRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourcePassPatch', 'id', id)
            // verify required parameter 'passRequestBody' is not null or undefined
            assertParamExists('patchItemResourcePassPatch', 'passRequestBody', passRequestBody)
            const localVarPath = `/passes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-pass
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourcePassPost: async (passRequestBody: PassRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passRequestBody' is not null or undefined
            assertParamExists('postCollectionResourcePassPost', 'passRequestBody', passRequestBody)
            const localVarPath = `/passes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourcePassPut: async (id: string, passRequestBody: PassRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourcePassPut', 'id', id)
            // verify required parameter 'passRequestBody' is not null or undefined
            assertParamExists('putItemResourcePassPut', 'passRequestBody', passRequestBody)
            const localVarPath = `/passes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PassEntityControllerApi - functional programming interface
 * @export
 */
export const PassEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PassEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourcePassDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourcePassDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.deleteItemResourcePassDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-pass
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourcePassGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourcePassGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.getCollectionResourcePassGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourcePassGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourcePassGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.getItemResourcePassGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourcePassPatch(id: string, passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourcePassPatch(id, passRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.patchItemResourcePassPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-pass
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourcePassPost(passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourcePassPost(passRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.postCollectionResourcePassPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourcePassPut(id: string, passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourcePassPut(id, passRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PassEntityControllerApi.putItemResourcePassPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PassEntityControllerApi - factory interface
 * @export
 */
export const PassEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PassEntityControllerApiFp(configuration)
    return {
        /**
         * delete-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourcePassDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourcePassDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-pass
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourcePassGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelPass> {
            return localVarFp.getCollectionResourcePassGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-pass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourcePassGet(id: string, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.getItemResourcePassGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourcePassPatch(id: string, passRequestBody: PassRequestBody, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.patchItemResourcePassPatch(id, passRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-pass
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourcePassPost(passRequestBody: PassRequestBody, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.postCollectionResourcePassPost(passRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-pass
         * @param {string} id 
         * @param {PassRequestBody} passRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourcePassPut(id: string, passRequestBody: PassRequestBody, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.putItemResourcePassPut(id, passRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PassEntityControllerApi - object-oriented interface
 * @export
 * @class PassEntityControllerApi
 * @extends {BaseAPI}
 */
export class PassEntityControllerApi extends BaseAPI {
    /**
     * delete-pass
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public deleteItemResourcePassDelete(id: string, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).deleteItemResourcePassDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-pass
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public getCollectionResourcePassGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).getCollectionResourcePassGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-pass
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public getItemResourcePassGet(id: string, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).getItemResourcePassGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-pass
     * @param {string} id 
     * @param {PassRequestBody} passRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public patchItemResourcePassPatch(id: string, passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).patchItemResourcePassPatch(id, passRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-pass
     * @param {PassRequestBody} passRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public postCollectionResourcePassPost(passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).postCollectionResourcePassPost(passRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-pass
     * @param {string} id 
     * @param {PassRequestBody} passRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassEntityControllerApi
     */
    public putItemResourcePassPut(id: string, passRequestBody: PassRequestBody, options?: RawAxiosRequestConfig) {
        return PassEntityControllerApiFp(this.configuration).putItemResourcePassPut(id, passRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentTypeEntityControllerApi - axios parameter creator
 * @export
 */
export const PaymentTypeEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-paymenttype
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourcePaymenttypeDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourcePaymenttypeDelete', 'id', id)
            const localVarPath = `/paymentTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-paymenttype
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourcePaymenttypeGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/paymentTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-paymenttype
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourcePaymenttypeGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourcePaymenttypeGet', 'id', id)
            const localVarPath = `/paymentTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-paymenttype
         * @param {string} id 
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourcePaymenttypePatch: async (id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourcePaymenttypePatch', 'id', id)
            // verify required parameter 'paymentTypeRequestBody' is not null or undefined
            assertParamExists('patchItemResourcePaymenttypePatch', 'paymentTypeRequestBody', paymentTypeRequestBody)
            const localVarPath = `/paymentTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentTypeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-paymenttype
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourcePaymenttypePost: async (paymentTypeRequestBody: PaymentTypeRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentTypeRequestBody' is not null or undefined
            assertParamExists('postCollectionResourcePaymenttypePost', 'paymentTypeRequestBody', paymentTypeRequestBody)
            const localVarPath = `/paymentTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentTypeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-paymenttype
         * @param {string} id 
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourcePaymenttypePut: async (id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourcePaymenttypePut', 'id', id)
            // verify required parameter 'paymentTypeRequestBody' is not null or undefined
            assertParamExists('putItemResourcePaymenttypePut', 'paymentTypeRequestBody', paymentTypeRequestBody)
            const localVarPath = `/paymentTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentTypeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentTypeEntityControllerApi - functional programming interface
 * @export
 */
export const PaymentTypeEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentTypeEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-paymenttype
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourcePaymenttypeDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourcePaymenttypeDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeEntityControllerApi.deleteItemResourcePaymenttypeDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-paymenttype
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourcePaymenttypeGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelPaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourcePaymenttypeGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeEntityControllerApi.getCollectionResourcePaymenttypeGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-paymenttype
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourcePaymenttypeGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourcePaymenttypeGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeEntityControllerApi.getItemResourcePaymenttypeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-paymenttype
         * @param {string} id 
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourcePaymenttypePatch(id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourcePaymenttypePatch(id, paymentTypeRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeEntityControllerApi.patchItemResourcePaymenttypePatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-paymenttype
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourcePaymenttypePost(paymentTypeRequestBody: PaymentTypeRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourcePaymenttypePost(paymentTypeRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeEntityControllerApi.postCollectionResourcePaymenttypePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-paymenttype
         * @param {string} id 
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourcePaymenttypePut(id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourcePaymenttypePut(id, paymentTypeRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeEntityControllerApi.putItemResourcePaymenttypePut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PaymentTypeEntityControllerApi - factory interface
 * @export
 */
export const PaymentTypeEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentTypeEntityControllerApiFp(configuration)
    return {
        /**
         * delete-paymenttype
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourcePaymenttypeDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourcePaymenttypeDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-paymenttype
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourcePaymenttypeGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelPaymentType> {
            return localVarFp.getCollectionResourcePaymenttypeGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-paymenttype
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourcePaymenttypeGet(id: string, options?: any): AxiosPromise<EntityModelPaymentType> {
            return localVarFp.getItemResourcePaymenttypeGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-paymenttype
         * @param {string} id 
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourcePaymenttypePatch(id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options?: any): AxiosPromise<EntityModelPaymentType> {
            return localVarFp.patchItemResourcePaymenttypePatch(id, paymentTypeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-paymenttype
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourcePaymenttypePost(paymentTypeRequestBody: PaymentTypeRequestBody, options?: any): AxiosPromise<EntityModelPaymentType> {
            return localVarFp.postCollectionResourcePaymenttypePost(paymentTypeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-paymenttype
         * @param {string} id 
         * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourcePaymenttypePut(id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options?: any): AxiosPromise<EntityModelPaymentType> {
            return localVarFp.putItemResourcePaymenttypePut(id, paymentTypeRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentTypeEntityControllerApi - object-oriented interface
 * @export
 * @class PaymentTypeEntityControllerApi
 * @extends {BaseAPI}
 */
export class PaymentTypeEntityControllerApi extends BaseAPI {
    /**
     * delete-paymenttype
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeEntityControllerApi
     */
    public deleteItemResourcePaymenttypeDelete(id: string, options?: RawAxiosRequestConfig) {
        return PaymentTypeEntityControllerApiFp(this.configuration).deleteItemResourcePaymenttypeDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-paymenttype
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeEntityControllerApi
     */
    public getCollectionResourcePaymenttypeGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return PaymentTypeEntityControllerApiFp(this.configuration).getCollectionResourcePaymenttypeGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-paymenttype
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeEntityControllerApi
     */
    public getItemResourcePaymenttypeGet(id: string, options?: RawAxiosRequestConfig) {
        return PaymentTypeEntityControllerApiFp(this.configuration).getItemResourcePaymenttypeGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-paymenttype
     * @param {string} id 
     * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeEntityControllerApi
     */
    public patchItemResourcePaymenttypePatch(id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options?: RawAxiosRequestConfig) {
        return PaymentTypeEntityControllerApiFp(this.configuration).patchItemResourcePaymenttypePatch(id, paymentTypeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-paymenttype
     * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeEntityControllerApi
     */
    public postCollectionResourcePaymenttypePost(paymentTypeRequestBody: PaymentTypeRequestBody, options?: RawAxiosRequestConfig) {
        return PaymentTypeEntityControllerApiFp(this.configuration).postCollectionResourcePaymenttypePost(paymentTypeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-paymenttype
     * @param {string} id 
     * @param {PaymentTypeRequestBody} paymentTypeRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeEntityControllerApi
     */
    public putItemResourcePaymenttypePut(id: string, paymentTypeRequestBody: PaymentTypeRequestBody, options?: RawAxiosRequestConfig) {
        return PaymentTypeEntityControllerApiFp(this.configuration).putItemResourcePaymenttypePut(id, paymentTypeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentTypePropertyReferenceControllerApi - axios parameter creator
 * @export
 */
export const PaymentTypePropertyReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * patch-user-by-paymenttype-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferencePaymenttypePatch: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferencePaymenttypePatch', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferencePaymenttypePatch', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/paymentTypes/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-user-by-paymenttype-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferencePaymenttypePut: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferencePaymenttypePut', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferencePaymenttypePut', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/paymentTypes/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-user-by-paymenttype-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdPaymenttypeDelete: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdPaymenttypeDelete', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdPaymenttypeDelete', 'propertyId', propertyId)
            const localVarPath = `/paymentTypes/{id}/user/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-user-by-paymenttype-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferencePaymenttypeDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferencePaymenttypeDelete', 'id', id)
            const localVarPath = `/paymentTypes/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user-by-paymenttype-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferencePaymenttypeGet: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferencePaymenttypeGet', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferencePaymenttypeGet', 'propertyId', propertyId)
            const localVarPath = `/paymentTypes/{id}/user/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user-by-paymenttype-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferencePaymenttypeGet1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferencePaymenttypeGet1', 'id', id)
            const localVarPath = `/paymentTypes/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentTypePropertyReferenceControllerApi - functional programming interface
 * @export
 */
export const PaymentTypePropertyReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentTypePropertyReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * patch-user-by-paymenttype-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferencePaymenttypePatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferencePaymenttypePatch(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypePropertyReferenceControllerApi.createPropertyReferencePaymenttypePatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-user-by-paymenttype-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferencePaymenttypePut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferencePaymenttypePut(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypePropertyReferenceControllerApi.createPropertyReferencePaymenttypePut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-user-by-paymenttype-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdPaymenttypeDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdPaymenttypeDelete(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypePropertyReferenceControllerApi.deletePropertyReferenceIdPaymenttypeDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-user-by-paymenttype-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferencePaymenttypeDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferencePaymenttypeDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypePropertyReferenceControllerApi.deletePropertyReferencePaymenttypeDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user-by-paymenttype-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferencePaymenttypeGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferencePaymenttypeGet(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypePropertyReferenceControllerApi.followPropertyReferencePaymenttypeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user-by-paymenttype-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferencePaymenttypeGet1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferencePaymenttypeGet1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypePropertyReferenceControllerApi.followPropertyReferencePaymenttypeGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PaymentTypePropertyReferenceControllerApi - factory interface
 * @export
 */
export const PaymentTypePropertyReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentTypePropertyReferenceControllerApiFp(configuration)
    return {
        /**
         * patch-user-by-paymenttype-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferencePaymenttypePatch(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.createPropertyReferencePaymenttypePatch(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-user-by-paymenttype-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferencePaymenttypePut(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.createPropertyReferencePaymenttypePut(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-user-by-paymenttype-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdPaymenttypeDelete(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdPaymenttypeDelete(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-user-by-paymenttype-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferencePaymenttypeDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferencePaymenttypeDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user-by-paymenttype-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferencePaymenttypeGet(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.followPropertyReferencePaymenttypeGet(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user-by-paymenttype-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferencePaymenttypeGet1(id: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.followPropertyReferencePaymenttypeGet1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentTypePropertyReferenceControllerApi - object-oriented interface
 * @export
 * @class PaymentTypePropertyReferenceControllerApi
 * @extends {BaseAPI}
 */
export class PaymentTypePropertyReferenceControllerApi extends BaseAPI {
    /**
     * patch-user-by-paymenttype-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypePropertyReferenceControllerApi
     */
    public createPropertyReferencePaymenttypePatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return PaymentTypePropertyReferenceControllerApiFp(this.configuration).createPropertyReferencePaymenttypePatch(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-user-by-paymenttype-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypePropertyReferenceControllerApi
     */
    public createPropertyReferencePaymenttypePut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return PaymentTypePropertyReferenceControllerApiFp(this.configuration).createPropertyReferencePaymenttypePut(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-user-by-paymenttype-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypePropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdPaymenttypeDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return PaymentTypePropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdPaymenttypeDelete(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-user-by-paymenttype-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypePropertyReferenceControllerApi
     */
    public deletePropertyReferencePaymenttypeDelete(id: string, options?: RawAxiosRequestConfig) {
        return PaymentTypePropertyReferenceControllerApiFp(this.configuration).deletePropertyReferencePaymenttypeDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user-by-paymenttype-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypePropertyReferenceControllerApi
     */
    public followPropertyReferencePaymenttypeGet(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return PaymentTypePropertyReferenceControllerApiFp(this.configuration).followPropertyReferencePaymenttypeGet(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user-by-paymenttype-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypePropertyReferenceControllerApi
     */
    public followPropertyReferencePaymenttypeGet1(id: string, options?: RawAxiosRequestConfig) {
        return PaymentTypePropertyReferenceControllerApiFp(this.configuration).followPropertyReferencePaymenttypeGet1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentTypeSearchControllerApi - axios parameter creator
 * @export
 */
export const PaymentTypeSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchPaymenttypeGet: async (userId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/paymentTypes/search/getAllByUserId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchPaymenttypeGet1: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/paymentTypes/search/getPaymentTypeById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentTypeSearchControllerApi - functional programming interface
 * @export
 */
export const PaymentTypeSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentTypeSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchPaymenttypeGet(userId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionModelEntityModelPaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchPaymenttypeGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeSearchControllerApi.executeSearchPaymenttypeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchPaymenttypeGet1(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchPaymenttypeGet1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentTypeSearchControllerApi.executeSearchPaymenttypeGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PaymentTypeSearchControllerApi - factory interface
 * @export
 */
export const PaymentTypeSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentTypeSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchPaymenttypeGet(userId?: number, options?: any): AxiosPromise<CollectionModelEntityModelPaymentType> {
            return localVarFp.executeSearchPaymenttypeGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchPaymenttypeGet1(id?: number, options?: any): AxiosPromise<EntityModelPaymentType> {
            return localVarFp.executeSearchPaymenttypeGet1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentTypeSearchControllerApi - object-oriented interface
 * @export
 * @class PaymentTypeSearchControllerApi
 * @extends {BaseAPI}
 */
export class PaymentTypeSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeSearchControllerApi
     */
    public executeSearchPaymenttypeGet(userId?: number, options?: RawAxiosRequestConfig) {
        return PaymentTypeSearchControllerApiFp(this.configuration).executeSearchPaymenttypeGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTypeSearchControllerApi
     */
    public executeSearchPaymenttypeGet1(id?: number, options?: RawAxiosRequestConfig) {
        return PaymentTypeSearchControllerApiFp(this.configuration).executeSearchPaymenttypeGet1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileControllerApi - axios parameter creator
 * @export
 */
export const ProfileControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor111: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor112: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/passes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor113: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/paymentTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor114: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor115: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor116: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/userWallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor117: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFormsOfMetadata1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileControllerApi - functional programming interface
 * @export
 */
export const ProfileControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor111(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor111(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor111']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor112(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor112(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor112']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor113(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor113(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor113']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor114(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor114(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor114']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor115(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor115(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor115']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor116(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor116(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor116']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor117(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor117(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor117']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllFormsOfMetadata1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepresentationModelObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllFormsOfMetadata1(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.listAllFormsOfMetadata1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProfileControllerApi - factory interface
 * @export
 */
export const ProfileControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor111(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor111(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor112(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor112(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor113(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor113(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor114(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor114(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor115(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor115(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor116(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor116(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor117(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor117(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFormsOfMetadata1(options?: any): AxiosPromise<RepresentationModelObject> {
            return localVarFp.listAllFormsOfMetadata1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileControllerApi - object-oriented interface
 * @export
 * @class ProfileControllerApi
 * @extends {BaseAPI}
 */
export class ProfileControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor111(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor111(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor112(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor112(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor113(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor113(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor114(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor114(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor115(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor115(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor116(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor116(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor117(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor117(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public listAllFormsOfMetadata1(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).listAllFormsOfMetadata1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StripeControllerApi - axios parameter creator
 * @export
 */
export const StripeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} token 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargeCard: async (token: string, amount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('chargeCard', 'token', token)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('chargeCard', 'amount', amount)
            const localVarPath = `/api/payment/charge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }

            if (amount != null) {
                localVarHeaderParameter['amount'] = typeof amount === 'string'
                    ? amount
                    : JSON.stringify(amount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeControllerApi - functional programming interface
 * @export
 */
export const StripeControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} token 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chargeCard(token: string, amount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Charge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chargeCard(token, amount, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StripeControllerApi.chargeCard']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * StripeControllerApi - factory interface
 * @export
 */
export const StripeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} token 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargeCard(token: string, amount: number, options?: any): AxiosPromise<Charge> {
            return localVarFp.chargeCard(token, amount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripeControllerApi - object-oriented interface
 * @export
 * @class StripeControllerApi
 * @extends {BaseAPI}
 */
export class StripeControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} token 
     * @param {number} amount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeControllerApi
     */
    public chargeCard(token: string, amount: number, options?: RawAxiosRequestConfig) {
        return StripeControllerApiFp(this.configuration).chargeCard(token, amount, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TicketEntityControllerApi - axios parameter creator
 * @export
 */
export const TicketEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceTicketDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceTicketDelete', 'id', id)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-ticket
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceTicketGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceTicketGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceTicketGet', 'id', id)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceTicketPatch: async (id: string, ticketRequestBody: TicketRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceTicketPatch', 'id', id)
            // verify required parameter 'ticketRequestBody' is not null or undefined
            assertParamExists('patchItemResourceTicketPatch', 'ticketRequestBody', ticketRequestBody)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-ticket
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceTicketPost: async (ticketRequestBody: TicketRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceTicketPost', 'ticketRequestBody', ticketRequestBody)
            const localVarPath = `/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceTicketPut: async (id: string, ticketRequestBody: TicketRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceTicketPut', 'id', id)
            // verify required parameter 'ticketRequestBody' is not null or undefined
            assertParamExists('putItemResourceTicketPut', 'ticketRequestBody', ticketRequestBody)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TicketEntityControllerApi - functional programming interface
 * @export
 */
export const TicketEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TicketEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceTicketDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceTicketDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.deleteItemResourceTicketDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-ticket
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceTicketGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceTicketGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.getCollectionResourceTicketGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceTicketGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceTicketGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.getItemResourceTicketGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceTicketPatch(id: string, ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceTicketPatch(id, ticketRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.patchItemResourceTicketPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-ticket
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceTicketPost(ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceTicketPost(ticketRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.postCollectionResourceTicketPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceTicketPut(id: string, ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceTicketPut(id, ticketRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketEntityControllerApi.putItemResourceTicketPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TicketEntityControllerApi - factory interface
 * @export
 */
export const TicketEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TicketEntityControllerApiFp(configuration)
    return {
        /**
         * delete-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceTicketDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceTicketDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-ticket
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceTicketGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelTicket> {
            return localVarFp.getCollectionResourceTicketGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceTicketGet(id: string, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.getItemResourceTicketGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceTicketPatch(id: string, ticketRequestBody: TicketRequestBody, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.patchItemResourceTicketPatch(id, ticketRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-ticket
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceTicketPost(ticketRequestBody: TicketRequestBody, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.postCollectionResourceTicketPost(ticketRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-ticket
         * @param {string} id 
         * @param {TicketRequestBody} ticketRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceTicketPut(id: string, ticketRequestBody: TicketRequestBody, options?: any): AxiosPromise<EntityModelTicket> {
            return localVarFp.putItemResourceTicketPut(id, ticketRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TicketEntityControllerApi - object-oriented interface
 * @export
 * @class TicketEntityControllerApi
 * @extends {BaseAPI}
 */
export class TicketEntityControllerApi extends BaseAPI {
    /**
     * delete-ticket
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public deleteItemResourceTicketDelete(id: string, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).deleteItemResourceTicketDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-ticket
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public getCollectionResourceTicketGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).getCollectionResourceTicketGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-ticket
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public getItemResourceTicketGet(id: string, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).getItemResourceTicketGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-ticket
     * @param {string} id 
     * @param {TicketRequestBody} ticketRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public patchItemResourceTicketPatch(id: string, ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).patchItemResourceTicketPatch(id, ticketRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-ticket
     * @param {TicketRequestBody} ticketRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public postCollectionResourceTicketPost(ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).postCollectionResourceTicketPost(ticketRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-ticket
     * @param {string} id 
     * @param {TicketRequestBody} ticketRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketEntityControllerApi
     */
    public putItemResourceTicketPut(id: string, ticketRequestBody: TicketRequestBody, options?: RawAxiosRequestConfig) {
        return TicketEntityControllerApiFp(this.configuration).putItemResourceTicketPut(id, ticketRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokenEntityControllerApi - axios parameter creator
 * @export
 */
export const TokenEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceTokenDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceTokenDelete', 'id', id)
            const localVarPath = `/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-token
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceTokenGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceTokenGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceTokenGet', 'id', id)
            const localVarPath = `/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceTokenPatch: async (id: string, tokenRequestBody: TokenRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceTokenPatch', 'id', id)
            // verify required parameter 'tokenRequestBody' is not null or undefined
            assertParamExists('patchItemResourceTokenPatch', 'tokenRequestBody', tokenRequestBody)
            const localVarPath = `/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-token
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceTokenPost: async (tokenRequestBody: TokenRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceTokenPost', 'tokenRequestBody', tokenRequestBody)
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceTokenPut: async (id: string, tokenRequestBody: TokenRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceTokenPut', 'id', id)
            // verify required parameter 'tokenRequestBody' is not null or undefined
            assertParamExists('putItemResourceTokenPut', 'tokenRequestBody', tokenRequestBody)
            const localVarPath = `/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenEntityControllerApi - functional programming interface
 * @export
 */
export const TokenEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceTokenDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceTokenDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.deleteItemResourceTokenDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-token
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceTokenGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceTokenGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.getCollectionResourceTokenGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceTokenGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceTokenGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.getItemResourceTokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceTokenPatch(id: string, tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceTokenPatch(id, tokenRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.patchItemResourceTokenPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-token
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceTokenPost(tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceTokenPost(tokenRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.postCollectionResourceTokenPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceTokenPut(id: string, tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceTokenPut(id, tokenRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenEntityControllerApi.putItemResourceTokenPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TokenEntityControllerApi - factory interface
 * @export
 */
export const TokenEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenEntityControllerApiFp(configuration)
    return {
        /**
         * delete-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceTokenDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceTokenDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-token
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceTokenGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelToken> {
            return localVarFp.getCollectionResourceTokenGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceTokenGet(id: string, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.getItemResourceTokenGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceTokenPatch(id: string, tokenRequestBody: TokenRequestBody, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.patchItemResourceTokenPatch(id, tokenRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-token
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceTokenPost(tokenRequestBody: TokenRequestBody, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.postCollectionResourceTokenPost(tokenRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-token
         * @param {string} id 
         * @param {TokenRequestBody} tokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceTokenPut(id: string, tokenRequestBody: TokenRequestBody, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.putItemResourceTokenPut(id, tokenRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenEntityControllerApi - object-oriented interface
 * @export
 * @class TokenEntityControllerApi
 * @extends {BaseAPI}
 */
export class TokenEntityControllerApi extends BaseAPI {
    /**
     * delete-token
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public deleteItemResourceTokenDelete(id: string, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).deleteItemResourceTokenDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-token
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public getCollectionResourceTokenGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).getCollectionResourceTokenGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-token
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public getItemResourceTokenGet(id: string, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).getItemResourceTokenGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-token
     * @param {string} id 
     * @param {TokenRequestBody} tokenRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public patchItemResourceTokenPatch(id: string, tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).patchItemResourceTokenPatch(id, tokenRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-token
     * @param {TokenRequestBody} tokenRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public postCollectionResourceTokenPost(tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).postCollectionResourceTokenPost(tokenRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-token
     * @param {string} id 
     * @param {TokenRequestBody} tokenRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEntityControllerApi
     */
    public putItemResourceTokenPut(id: string, tokenRequestBody: TokenRequestBody, options?: RawAxiosRequestConfig) {
        return TokenEntityControllerApiFp(this.configuration).putItemResourceTokenPut(id, tokenRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokenPropertyReferenceControllerApi - axios parameter creator
 * @export
 */
export const TokenPropertyReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * patch-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceTokenPatch: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceTokenPatch', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceTokenPatch', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/tokens/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceTokenPut: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceTokenPut', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceTokenPut', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/tokens/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdTokenDelete: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdTokenDelete', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdTokenDelete', 'propertyId', propertyId)
            const localVarPath = `/tokens/{id}/user/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceTokenDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceTokenDelete', 'id', id)
            const localVarPath = `/tokens/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceTokenGet: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceTokenGet', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceTokenGet', 'propertyId', propertyId)
            const localVarPath = `/tokens/{id}/user/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceTokenGet1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceTokenGet1', 'id', id)
            const localVarPath = `/tokens/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenPropertyReferenceControllerApi - functional programming interface
 * @export
 */
export const TokenPropertyReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenPropertyReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * patch-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceTokenPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceTokenPatch(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.createPropertyReferenceTokenPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceTokenPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceTokenPut(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.createPropertyReferenceTokenPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdTokenDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdTokenDelete(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.deletePropertyReferenceIdTokenDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceTokenDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceTokenDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.deletePropertyReferenceTokenDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceTokenGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceTokenGet(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.followPropertyReferenceTokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceTokenGet1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceTokenGet1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenPropertyReferenceControllerApi.followPropertyReferenceTokenGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TokenPropertyReferenceControllerApi - factory interface
 * @export
 */
export const TokenPropertyReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenPropertyReferenceControllerApiFp(configuration)
    return {
        /**
         * patch-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceTokenPatch(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.createPropertyReferenceTokenPatch(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-user-by-token-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceTokenPut(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.createPropertyReferenceTokenPut(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdTokenDelete(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdTokenDelete(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceTokenDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceTokenDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceTokenGet(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.followPropertyReferenceTokenGet(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user-by-token-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceTokenGet1(id: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.followPropertyReferenceTokenGet1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenPropertyReferenceControllerApi - object-oriented interface
 * @export
 * @class TokenPropertyReferenceControllerApi
 * @extends {BaseAPI}
 */
export class TokenPropertyReferenceControllerApi extends BaseAPI {
    /**
     * patch-user-by-token-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public createPropertyReferenceTokenPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceTokenPatch(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-user-by-token-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public createPropertyReferenceTokenPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceTokenPut(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-user-by-token-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdTokenDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdTokenDelete(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-user-by-token-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public deletePropertyReferenceTokenDelete(id: string, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceTokenDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user-by-token-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public followPropertyReferenceTokenGet(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceTokenGet(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user-by-token-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenPropertyReferenceControllerApi
     */
    public followPropertyReferenceTokenGet1(id: string, options?: RawAxiosRequestConfig) {
        return TokenPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceTokenGet1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokenSearchControllerApi - axios parameter creator
 * @export
 */
export const TokenSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTokenGet: async (token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens/search/findByToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTokenGet1: async (user?: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens/search/findByUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (user !== undefined) {
                for (const [key, value] of Object.entries(user)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenSearchControllerApi - functional programming interface
 * @export
 */
export const TokenSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchTokenGet(token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchTokenGet(token, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenSearchControllerApi.executeSearchTokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchTokenGet1(user?: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchTokenGet1(user, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenSearchControllerApi.executeSearchTokenGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TokenSearchControllerApi - factory interface
 * @export
 */
export const TokenSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTokenGet(token?: string, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.executeSearchTokenGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchTokenGet1(user?: User, options?: any): AxiosPromise<EntityModelToken> {
            return localVarFp.executeSearchTokenGet1(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenSearchControllerApi - object-oriented interface
 * @export
 * @class TokenSearchControllerApi
 * @extends {BaseAPI}
 */
export class TokenSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [token] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenSearchControllerApi
     */
    public executeSearchTokenGet(token?: string, options?: RawAxiosRequestConfig) {
        return TokenSearchControllerApiFp(this.configuration).executeSearchTokenGet(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenSearchControllerApi
     */
    public executeSearchTokenGet1(user?: User, options?: RawAxiosRequestConfig) {
        return TokenSearchControllerApiFp(this.configuration).executeSearchTokenGet1(user, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a user\'s profile image url.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserImage: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserImage', 'userId', userId)
            const localVarPath = `/user/get-user-pfp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a user\'s by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUserAsDeleted: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/delete-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user\'s profile image.
         * @param {SetUserImageRequest} [setUserImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserImage: async (setUserImageRequest?: SetUserImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/upload-profile-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user info by their ID.
         * @param {UpdateUserDTO} userNewInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userNewInfo: UpdateUserDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userNewInfo' is not null or undefined
            assertParamExists('updateUser', 'userNewInfo', userNewInfo)
            const localVarPath = `/user/update-user-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userNewInfo !== undefined) {
                for (const [key, value] of Object.entries(userNewInfo)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserControllerApi.getUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a user\'s profile image url.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserImage(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserImage(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserControllerApi.getUserImage']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a user\'s by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markUserAsDeleted(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markUserAsDeleted(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserControllerApi.markUserAsDeleted']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a user\'s profile image.
         * @param {SetUserImageRequest} [setUserImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserImage(setUserImageRequest?: SetUserImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserImage(setUserImageRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserControllerApi.setUserImage']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a user info by their ID.
         * @param {UpdateUserDTO} userNewInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userNewInfo: UpdateUserDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userNewInfo, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserControllerApi.updateUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s information by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<User> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a user\'s profile image url.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserImage(userId: number, options?: any): AxiosPromise<string> {
            return localVarFp.getUserImage(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a user\'s by their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUserAsDeleted(options?: any): AxiosPromise<User> {
            return localVarFp.markUserAsDeleted(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user\'s profile image.
         * @param {SetUserImageRequest} [setUserImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserImage(setUserImageRequest?: SetUserImageRequest, options?: any): AxiosPromise<string> {
            return localVarFp.setUserImage(setUserImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user info by their ID.
         * @param {UpdateUserDTO} userNewInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userNewInfo: UpdateUserDTO, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(userNewInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @summary Gets a user\'s information by their ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUser(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a user\'s profile image url.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserImage(userId: number, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getUserImage(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a user\'s by their ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public markUserAsDeleted(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).markUserAsDeleted(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user\'s profile image.
     * @param {SetUserImageRequest} [setUserImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public setUserImage(setUserImageRequest?: SetUserImageRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).setUserImage(setUserImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user info by their ID.
     * @param {UpdateUserDTO} userNewInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updateUser(userNewInfo: UpdateUserDTO, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).updateUser(userNewInfo, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserEntityControllerApi - axios parameter creator
 * @export
 */
export const UserEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceUserDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceUserDelete', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceUserGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceUserGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceUserGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceUserPatch: async (id: string, userRequestBody: UserRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceUserPatch', 'id', id)
            // verify required parameter 'userRequestBody' is not null or undefined
            assertParamExists('patchItemResourceUserPatch', 'userRequestBody', userRequestBody)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-user
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceUserPost: async (userRequestBody: UserRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceUserPost', 'userRequestBody', userRequestBody)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceUserPut: async (id: string, userRequestBody: UserRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceUserPut', 'id', id)
            // verify required parameter 'userRequestBody' is not null or undefined
            assertParamExists('putItemResourceUserPut', 'userRequestBody', userRequestBody)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserEntityControllerApi - functional programming interface
 * @export
 */
export const UserEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceUserDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceUserDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.deleteItemResourceUserDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceUserGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceUserGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.getCollectionResourceUserGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceUserGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceUserGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.getItemResourceUserGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceUserPatch(id: string, userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceUserPatch(id, userRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.patchItemResourceUserPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-user
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceUserPost(userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceUserPost(userRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.postCollectionResourceUserPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceUserPut(id: string, userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceUserPut(id, userRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserEntityControllerApi.putItemResourceUserPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserEntityControllerApi - factory interface
 * @export
 */
export const UserEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserEntityControllerApiFp(configuration)
    return {
        /**
         * delete-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceUserDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceUserDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceUserGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelUser> {
            return localVarFp.getCollectionResourceUserGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceUserGet(id: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.getItemResourceUserGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceUserPatch(id: string, userRequestBody: UserRequestBody, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.patchItemResourceUserPatch(id, userRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-user
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceUserPost(userRequestBody: UserRequestBody, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.postCollectionResourceUserPost(userRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-user
         * @param {string} id 
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceUserPut(id: string, userRequestBody: UserRequestBody, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.putItemResourceUserPut(id, userRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserEntityControllerApi - object-oriented interface
 * @export
 * @class UserEntityControllerApi
 * @extends {BaseAPI}
 */
export class UserEntityControllerApi extends BaseAPI {
    /**
     * delete-user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public deleteItemResourceUserDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).deleteItemResourceUserDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public getCollectionResourceUserGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).getCollectionResourceUserGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public getItemResourceUserGet(id: string, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).getItemResourceUserGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-user
     * @param {string} id 
     * @param {UserRequestBody} userRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public patchItemResourceUserPatch(id: string, userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).patchItemResourceUserPatch(id, userRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-user
     * @param {UserRequestBody} userRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public postCollectionResourceUserPost(userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).postCollectionResourceUserPost(userRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-user
     * @param {string} id 
     * @param {UserRequestBody} userRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEntityControllerApi
     */
    public putItemResourceUserPut(id: string, userRequestBody: UserRequestBody, options?: RawAxiosRequestConfig) {
        return UserEntityControllerApiFp(this.configuration).putItemResourceUserPut(id, userRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserPropertyReferenceControllerApi - axios parameter creator
 * @export
 */
export const UserPropertyReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * patch-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPatch: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserPatch', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserPatch', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/users/{id}/pass`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPatch1: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserPatch1', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserPatch1', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/users/{id}/wallet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPut: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserPut', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserPut', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/users/{id}/pass`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPut1: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserPut1', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserPut1', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/users/{id}/wallet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserDelete: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserDelete', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserDelete', 'propertyId', propertyId)
            const localVarPath = `/users/{id}/pass/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserDelete1: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserDelete1', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserDelete1', 'propertyId', propertyId)
            const localVarPath = `/users/{id}/wallet/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceUserDelete', 'id', id)
            const localVarPath = `/users/{id}/pass`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserDelete1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceUserDelete1', 'id', id)
            const localVarPath = `/users/{id}/wallet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet', 'propertyId', propertyId)
            const localVarPath = `/users/{id}/pass/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet1', 'id', id)
            const localVarPath = `/users/{id}/pass`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet2: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet2', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet2', 'propertyId', propertyId)
            const localVarPath = `/users/{id}/wallet/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet21: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserGet21', 'id', id)
            const localVarPath = `/users/{id}/wallet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPropertyReferenceControllerApi - functional programming interface
 * @export
 */
export const UserPropertyReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPropertyReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * patch-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserPatch(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.createPropertyReferenceUserPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserPatch1(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserPatch1(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.createPropertyReferenceUserPatch1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserPut(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.createPropertyReferenceUserPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserPut1(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserPut1(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.createPropertyReferenceUserPut1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdUserDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdUserDelete(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.deletePropertyReferenceIdUserDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdUserDelete1(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdUserDelete1(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.deletePropertyReferenceIdUserDelete1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceUserDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceUserDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.deletePropertyReferenceUserDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceUserDelete1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceUserDelete1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.deletePropertyReferenceUserDelete1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserGet(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.followPropertyReferenceUserGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserGet1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserGet1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.followPropertyReferenceUserGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserGet2(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserGet2(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.followPropertyReferenceUserGet2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserGet21(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserGet21(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertyReferenceControllerApi.followPropertyReferenceUserGet21']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserPropertyReferenceControllerApi - factory interface
 * @export
 */
export const UserPropertyReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPropertyReferenceControllerApiFp(configuration)
    return {
        /**
         * patch-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPatch(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.createPropertyReferenceUserPatch(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPatch1(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.createPropertyReferenceUserPatch1(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-pass-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPut(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.createPropertyReferenceUserPut(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-userwallet-by-user-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserPut1(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.createPropertyReferenceUserPut1(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserDelete(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdUserDelete(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserDelete1(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdUserDelete1(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceUserDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserDelete1(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceUserDelete1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.followPropertyReferenceUserGet(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-pass-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet1(id: string, options?: any): AxiosPromise<EntityModelPass> {
            return localVarFp.followPropertyReferenceUserGet1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet2(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.followPropertyReferenceUserGet2(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-userwallet-by-user-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserGet21(id: string, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.followPropertyReferenceUserGet21(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPropertyReferenceControllerApi - object-oriented interface
 * @export
 * @class UserPropertyReferenceControllerApi
 * @extends {BaseAPI}
 */
export class UserPropertyReferenceControllerApi extends BaseAPI {
    /**
     * patch-pass-by-user-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserPatch(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-userwallet-by-user-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserPatch1(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserPatch1(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-pass-by-user-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserPut(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-userwallet-by-user-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserPut1(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserPut1(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-pass-by-user-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdUserDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdUserDelete(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-userwallet-by-user-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdUserDelete1(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdUserDelete1(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-pass-by-user-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public deletePropertyReferenceUserDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceUserDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-userwallet-by-user-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public deletePropertyReferenceUserDelete1(id: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceUserDelete1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-pass-by-user-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserGet(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserGet(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-pass-by-user-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserGet1(id: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserGet1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-userwallet-by-user-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserGet2(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserGet2(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-userwallet-by-user-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserGet21(id: string, options?: RawAxiosRequestConfig) {
        return UserPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserGet21(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserSearchControllerApi - axios parameter creator
 * @export
 */
export const UserSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet: async (email?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/existsByEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet1: async (email?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/findByEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet2: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/findProfileImageUrlById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet3: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/getUserById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSearchControllerApi - functional programming interface
 * @export
 */
export const UserSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserGet(email?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserGet(email, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchControllerApi.executeSearchUserGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserGet1(email?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserGet1(email, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchControllerApi.executeSearchUserGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserGet2(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserGet2(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchControllerApi.executeSearchUserGet2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchUserGet3(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchUserGet3(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchControllerApi.executeSearchUserGet3']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserSearchControllerApi - factory interface
 * @export
 */
export const UserSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet(email?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.executeSearchUserGet(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet1(email?: string, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.executeSearchUserGet1(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet2(id?: number, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.executeSearchUserGet2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchUserGet3(id?: number, options?: any): AxiosPromise<EntityModelUser> {
            return localVarFp.executeSearchUserGet3(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSearchControllerApi - object-oriented interface
 * @export
 * @class UserSearchControllerApi
 * @extends {BaseAPI}
 */
export class UserSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchControllerApi
     */
    public executeSearchUserGet(email?: string, options?: RawAxiosRequestConfig) {
        return UserSearchControllerApiFp(this.configuration).executeSearchUserGet(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchControllerApi
     */
    public executeSearchUserGet1(email?: string, options?: RawAxiosRequestConfig) {
        return UserSearchControllerApiFp(this.configuration).executeSearchUserGet1(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchControllerApi
     */
    public executeSearchUserGet2(id?: number, options?: RawAxiosRequestConfig) {
        return UserSearchControllerApiFp(this.configuration).executeSearchUserGet2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchControllerApi
     */
    public executeSearchUserGet3(id?: number, options?: RawAxiosRequestConfig) {
        return UserSearchControllerApiFp(this.configuration).executeSearchUserGet3(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserWalletEntityControllerApi - axios parameter creator
 * @export
 */
export const UserWalletEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceUserwalletDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceUserwalletDelete', 'id', id)
            const localVarPath = `/userWallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-userwallet
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceUserwalletGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userWallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceUserwalletGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceUserwalletGet', 'id', id)
            const localVarPath = `/userWallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceUserwalletPatch: async (id: string, userWalletRequestBody: UserWalletRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceUserwalletPatch', 'id', id)
            // verify required parameter 'userWalletRequestBody' is not null or undefined
            assertParamExists('patchItemResourceUserwalletPatch', 'userWalletRequestBody', userWalletRequestBody)
            const localVarPath = `/userWallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWalletRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-userwallet
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceUserwalletPost: async (userWalletRequestBody: UserWalletRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userWalletRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceUserwalletPost', 'userWalletRequestBody', userWalletRequestBody)
            const localVarPath = `/userWallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWalletRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceUserwalletPut: async (id: string, userWalletRequestBody: UserWalletRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceUserwalletPut', 'id', id)
            // verify required parameter 'userWalletRequestBody' is not null or undefined
            assertParamExists('putItemResourceUserwalletPut', 'userWalletRequestBody', userWalletRequestBody)
            const localVarPath = `/userWallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWalletRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserWalletEntityControllerApi - functional programming interface
 * @export
 */
export const UserWalletEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserWalletEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceUserwalletDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceUserwalletDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.deleteItemResourceUserwalletDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-userwallet
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceUserwalletGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceUserwalletGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.getCollectionResourceUserwalletGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceUserwalletGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceUserwalletGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.getItemResourceUserwalletGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceUserwalletPatch(id: string, userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceUserwalletPatch(id, userWalletRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.patchItemResourceUserwalletPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-userwallet
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceUserwalletPost(userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceUserwalletPost(userWalletRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.postCollectionResourceUserwalletPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceUserwalletPut(id: string, userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelUserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceUserwalletPut(id, userWalletRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletEntityControllerApi.putItemResourceUserwalletPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserWalletEntityControllerApi - factory interface
 * @export
 */
export const UserWalletEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserWalletEntityControllerApiFp(configuration)
    return {
        /**
         * delete-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceUserwalletDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceUserwalletDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-userwallet
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceUserwalletGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelUserWallet> {
            return localVarFp.getCollectionResourceUserwalletGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-userwallet
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceUserwalletGet(id: string, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.getItemResourceUserwalletGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceUserwalletPatch(id: string, userWalletRequestBody: UserWalletRequestBody, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.patchItemResourceUserwalletPatch(id, userWalletRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-userwallet
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceUserwalletPost(userWalletRequestBody: UserWalletRequestBody, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.postCollectionResourceUserwalletPost(userWalletRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-userwallet
         * @param {string} id 
         * @param {UserWalletRequestBody} userWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceUserwalletPut(id: string, userWalletRequestBody: UserWalletRequestBody, options?: any): AxiosPromise<EntityModelUserWallet> {
            return localVarFp.putItemResourceUserwalletPut(id, userWalletRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserWalletEntityControllerApi - object-oriented interface
 * @export
 * @class UserWalletEntityControllerApi
 * @extends {BaseAPI}
 */
export class UserWalletEntityControllerApi extends BaseAPI {
    /**
     * delete-userwallet
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public deleteItemResourceUserwalletDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).deleteItemResourceUserwalletDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-userwallet
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public getCollectionResourceUserwalletGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).getCollectionResourceUserwalletGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-userwallet
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public getItemResourceUserwalletGet(id: string, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).getItemResourceUserwalletGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-userwallet
     * @param {string} id 
     * @param {UserWalletRequestBody} userWalletRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public patchItemResourceUserwalletPatch(id: string, userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).patchItemResourceUserwalletPatch(id, userWalletRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-userwallet
     * @param {UserWalletRequestBody} userWalletRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public postCollectionResourceUserwalletPost(userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).postCollectionResourceUserwalletPost(userWalletRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-userwallet
     * @param {string} id 
     * @param {UserWalletRequestBody} userWalletRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletEntityControllerApi
     */
    public putItemResourceUserwalletPut(id: string, userWalletRequestBody: UserWalletRequestBody, options?: RawAxiosRequestConfig) {
        return UserWalletEntityControllerApiFp(this.configuration).putItemResourceUserwalletPut(id, userWalletRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserWalletPropertyReferenceControllerApi - axios parameter creator
 * @export
 */
export const UserWalletPropertyReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * patch-membership-by-userwallet-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserwalletPatch: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserwalletPatch', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserwalletPatch', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/userWallets/{id}/membershipType`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-membership-by-userwallet-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserwalletPut: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceUserwalletPut', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceUserwalletPut', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/userWallets/{id}/membershipType`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-membership-by-userwallet-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserwalletDelete: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserwalletDelete', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdUserwalletDelete', 'propertyId', propertyId)
            const localVarPath = `/userWallets/{id}/membershipType/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-membership-by-userwallet-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserwalletDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceUserwalletDelete', 'id', id)
            const localVarPath = `/userWallets/{id}/membershipType`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-membership-by-userwallet-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserwalletGet: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserwalletGet', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceUserwalletGet', 'propertyId', propertyId)
            const localVarPath = `/userWallets/{id}/membershipType/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-membership-by-userwallet-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserwalletGet1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceUserwalletGet1', 'id', id)
            const localVarPath = `/userWallets/{id}/membershipType`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserWalletPropertyReferenceControllerApi - functional programming interface
 * @export
 */
export const UserWalletPropertyReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserWalletPropertyReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * patch-membership-by-userwallet-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserwalletPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserwalletPatch(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletPropertyReferenceControllerApi.createPropertyReferenceUserwalletPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-membership-by-userwallet-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceUserwalletPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceUserwalletPut(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletPropertyReferenceControllerApi.createPropertyReferenceUserwalletPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-membership-by-userwallet-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdUserwalletDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdUserwalletDelete(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletPropertyReferenceControllerApi.deletePropertyReferenceIdUserwalletDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-membership-by-userwallet-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceUserwalletDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceUserwalletDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletPropertyReferenceControllerApi.deletePropertyReferenceUserwalletDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-membership-by-userwallet-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserwalletGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserwalletGet(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletPropertyReferenceControllerApi.followPropertyReferenceUserwalletGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-membership-by-userwallet-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceUserwalletGet1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceUserwalletGet1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserWalletPropertyReferenceControllerApi.followPropertyReferenceUserwalletGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserWalletPropertyReferenceControllerApi - factory interface
 * @export
 */
export const UserWalletPropertyReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserWalletPropertyReferenceControllerApiFp(configuration)
    return {
        /**
         * patch-membership-by-userwallet-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserwalletPatch(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.createPropertyReferenceUserwalletPatch(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-membership-by-userwallet-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceUserwalletPut(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.createPropertyReferenceUserwalletPut(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-membership-by-userwallet-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdUserwalletDelete(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdUserwalletDelete(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-membership-by-userwallet-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceUserwalletDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceUserwalletDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-membership-by-userwallet-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserwalletGet(id: string, propertyId: string, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.followPropertyReferenceUserwalletGet(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-membership-by-userwallet-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceUserwalletGet1(id: string, options?: any): AxiosPromise<EntityModelMembership> {
            return localVarFp.followPropertyReferenceUserwalletGet1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserWalletPropertyReferenceControllerApi - object-oriented interface
 * @export
 * @class UserWalletPropertyReferenceControllerApi
 * @extends {BaseAPI}
 */
export class UserWalletPropertyReferenceControllerApi extends BaseAPI {
    /**
     * patch-membership-by-userwallet-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserwalletPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserWalletPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserwalletPatch(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-membership-by-userwallet-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletPropertyReferenceControllerApi
     */
    public createPropertyReferenceUserwalletPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return UserWalletPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceUserwalletPut(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-membership-by-userwallet-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletPropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdUserwalletDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserWalletPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdUserwalletDelete(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-membership-by-userwallet-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletPropertyReferenceControllerApi
     */
    public deletePropertyReferenceUserwalletDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserWalletPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceUserwalletDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-membership-by-userwallet-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserwalletGet(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return UserWalletPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserwalletGet(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-membership-by-userwallet-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletPropertyReferenceControllerApi
     */
    public followPropertyReferenceUserwalletGet1(id: string, options?: RawAxiosRequestConfig) {
        return UserWalletPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceUserwalletGet1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletControllerApi - axios parameter creator
 * @export
 */
export const WalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a user\'s wallet information by their ID.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletByUserId: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserWalletByUserId', 'userId', userId)
            const localVarPath = `/wallet/wallet-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletControllerApi - functional programming interface
 * @export
 */
export const WalletControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s wallet information by their ID.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletByUserId(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWalletByUserId(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WalletControllerApi.getUserWalletByUserId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * WalletControllerApi - factory interface
 * @export
 */
export const WalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets a user\'s wallet information by their ID.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletByUserId(userId: number, options?: any): AxiosPromise<UserWallet> {
            return localVarFp.getUserWalletByUserId(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletControllerApi - object-oriented interface
 * @export
 * @class WalletControllerApi
 * @extends {BaseAPI}
 */
export class WalletControllerApi extends BaseAPI {
    /**
     * 
     * @summary Gets a user\'s wallet information by their ID.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getUserWalletByUserId(userId: number, options?: RawAxiosRequestConfig) {
        return WalletControllerApiFp(this.configuration).getUserWalletByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



